import Vue from 'vue'
import Vuex from 'vuex'

Vue.use(Vuex)

export default new Vuex.Store({
  state: {
    database: [
      {
        id: 1,
        name: 'ZEROL',
        day: '22',
        category: 'JavaScript',
        title: 'setTimeout 和 setInterval，你们两位同学注意点时间~ ',
        intro: '你们两位同学注意点时间~',
        imgsrc: require('../assets/image/ArticleImg2.webp'),
        content:
        '## 一、基本定义与用法 \n### 1、定义\n-   `setTimeout()`方法用于在指定的时间（单位毫秒）后执行回调函数或指定的一段代码\n-   `setInterval()`方法可按照指定的时间间隔（单位毫秒）来调用回调函数或指定的一段代码\n### 2、参数\n-   第一个参数 function，必填，回调函数。或者是一段字符串代码，但是这种方式不建议使用，就和使用`eval()`一样，有安全风险；而且还有作用域问题（字符串会在全局作用域内被解释执行）\n```\nsetTimeout(\'console.log(123);fn()\', 2000)\n```\n-   第二个参数 delay，可选，单位是 ms，对于`setTimeout`是延迟时间，对于`setInterval`是间隔时间，默认都是 0\n-   第三个参数 param1,param2,param3...，可选，是传递给回调函数的参数，不大常用\n ```\nsetTimeout(function (a, b) {\nconsole.log(a, b)\n}, 2000, \'我是\', \'定时器\')\n```\n### 3、返回值\n-   返回一个 ID（数字），可以将这个 ID 传递给`clearTimeout()`或`clearInterval()`来取消执行\n-   PS: `setTimeout()`和`setInterval()`共用一个编号池，技术上，`clearTimeout()`和`clearInterval()`可以互换使用，但是为了避免混淆，一般不这么做\n## 二、setTimeout 和 setInterval 的实际表现\n### 1、使用 setInterval 实现计时\n```\nconst startTime = new Date().getTime()\nlet count = 0\nconst interval = setInterval(function () {\ncount++\nconsole.log(new Date().getTime() - (startTime + count * 1000) + \'ms\')\nif(count === 10){\nclearInterval(interval);\n}\n}, 1000)\n```\n`new Date().getTime() - (startTime + count * 1000)`理想情况下应该是 0ms，然而事实并不是这样，而是存在着误差：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba8397cf6a184ed6a32b285693cff3c0~tplv-k3u1fbpfcp-zoom-1.image)\n### 2、使用 setTimeout 实现计时\n```\nconst startTime = new Date().getTime(), delay = 1000\nlet count = 0\nlet timer = setTimeout(doFunc, delay)\nfunction doFunc(){\ncount++\nconsole.log(new Date().getTime() - (startTime + count * 1000) + \'ms\')\nif(count < 10){\ntimer = setTimeout(doFunc, delay)\n}\n}\n```\nsetTimeout 也同样存在着误差，而且时间越来越大（setTimeout 需要在同步代码执行完成后才重新开始计时）：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c59850b3ac2a475eb718b5492630d88e~tplv-k3u1fbpfcp-zoom-1.image)\n## 三、为什么会出现误差\n### 1、setTimeout 的最短延迟时间\n`setTimeout`遵循的规范由 whatwg 来维护，在 [HTML Standard - 8.6 Timers](https://link.juejin.cn?target=https%3A%2F%2Fhtml.spec.whatwg.org%2Fmultipage%2Ftimers-and-user-prompts.html%23dom-settimeout "https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-settimeout") 中写到了定义定时器的详细步骤，其中有两条：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ffbfbab446fe494fb44c54181f48aa31~tplv-k3u1fbpfcp-zoom-1.image)\n上面的意思就是说，如果设置的 timeout 小于 0，则设置为 0，如果嵌套的层级超过了 5 层（计时器嵌套），并且 timeout 小于 4ms，则设置 timeout 为 4ms。并且，在不同浏览器中出现这种最小延迟的情况有所不同\n具体的源代码实现以及各大浏览器实现的不同，大家可以参考这篇文章：[为什么 setTimeout 有最小延时 4ms ？](https://link.juejin.cn?target=https%3A%2F%2Fwww.bruceyj.com%2Ffront-end-interview-summary%2Fsystem-design%2Fwhy-is-the-design%2F2-why-setTimeout-4ms.html "https://www.bruceyj.com/front-end-interview-summary/system-design/why-is-the-design/2-why-setTimeout-4ms.html")\n这里只看结论，定时器本身的定义步骤是造成其出现误差的原因之一\n### 2、setInterval 的最小间隔时间以及回调函数阻塞\n在 HTML5 标准中，setInterval 的最小间隔为 10ms，虽然我在规范文档中并未找到其相关说明，但是经过实际测试，也确实存在最小间隔时间，例如以下代码：\n```\nlet startTime = new Date().getTime()\nlet count = 0\nconst interval = setInterval(function () {\ncount++\n console.log(new Date().getTime() - startTime + \'ms\')\nstartTime = new Date().getTime()\nif(count === 10) {\nclearInterval(interval)\n}\n}, 0)\n```\n测试结果：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9bcffa807d384a7ab542fd1174186b12~tplv-k3u1fbpfcp-zoom-1.image)\n虽然没有 10ms 那么大的间隔，但是间隔仍然存在，猜测具体的间隔时间是和浏览器实现以及设备性能有关，无论如何，间隔是确实存在的\n另外，当使用 setInterval 时间间隔到点后，仅当队列中没有该定时器的任何其他代码实例时，才会将定时器的代码添加到队列中，如果有的话，则不会添加，造成堵塞，这个也与 JS 的事件循环有关\n### 3、未被激活的tabs的定时最小延迟 >= 1000ms\n为了优化后台 tab 的加载损耗（以及降低耗电量），在未被激活的 tab 中定时器的最小延时限制为1s(1000ms)，具体时间在不同的浏览器实现中也有差别\n### 4、JS 的事件循环机制\n`setTimeout`和`setInterval`中的时间并不是到点就立即执行，而是到点将其回调函数加入异步事件队列中，按照队列先进先出的性质，该回调函数到点之后是否能执行还得取决于是否属于队列首位，如果前头还有其他事件在等待，则不能按点执行，如果没有，则将其放入同步队列执行。具体事件循环机制，可以参考这篇文章：[动图学习-EventLoop](https://juejin.cn/post/6969028296893792286 "https://juejin.cn/post/6969028296893792286")\n## 四、解决方案\n### 1、在浏览器中实现一个 0ms 延时的定时器\n可以参考如下代码（来自于国外的一篇博客，也是 MDN 推荐的方法），主要是使用了 postMessage 方法，异步的执行了回调函数，并且速度要比 setTimeout(0) 要快的多。具体比较可以参照原文：[setTimeout with a shorter delay](https://link.juejin.cn?target=https%3A%2F%2Fdbaron.org%2Flog%2F20100309-faster-timeouts "https://dbaron.org/log/20100309-faster-timeouts")\n使用 setTimeout(0) 得到的时间：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8994a7da32e549cd9d06c34d1ac0bbc8~tplv-k3u1fbpfcp-zoom-1.image)\n将 setTimeout 改成 setZeroTimeout 后得到的时间，时间几乎都在 0～1，至于为什么不是绝对的 0，猜测可能与性能有关，总的来说，时间确实缩短了：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dced5471b7fc422d9f9eb28259b26ce2~tplv-k3u1fbpfcp-zoom-1.image)\n### 2、购物网站的秒杀活动\n一般情况下，从服务器拿到倒数时间后，前端的执行倒计时程序持续运行，事实上，显示时间相比实际时间会越来越慢的\n究其原因，倒计时通常是使用定时器实现，而 JS 的单线程特性使得同步任务执行过程中出现阻塞时，任务队列中的异步任务并不能及时执行，因此浏览器并不能保证在定时器设置的时间结束后代码总是被准时执行，从而造成了倒计时的偏差\n一般的解决方法是前端定时向服务器发送请求获取最新的时间差来校准倒计时时间，和用户一直按 F5 刷新没啥区别，比较简单粗暴，下面的方法可以一定程度上解决这个问题，纯前端控制，不依赖于后端。源地址已忘\n## 五、使用 setTimeout 替代 setInterval\n定时器指定的时间间隔，表示的是何时将定时器的代码添加到消息队列，而不是何时执行代码。所以真正何时执行代码的时间是不能保证的，它取决于何时被主线程的事件循环获取到，并执行\n假设有 `setInterval(function, 100)`，它的执行可能是这样的：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/30346ef998214cabb6c95141b19ad25f~tplv-k3u1fbpfcp-zoom-1.image)\n上图可见，setInterval 每隔 100ms 往队列中添加一个事件；100ms 后，添加 T1 定时器代码至队列中，主线程中还有任务在执行，所以等待，some event 执行结束后执行 T1 定时器代码；又过了100ms，T2定时器被添加到队列中，主线程还在执行 T1 代码，所以等待；又过了 100ms，理论上又要往队列里推一个定时器代码，但由于此时 T2 还在队列中，所以 T3 不会被添加，结果就是此时被跳过；然后，T1 定时器执行结束后马上执行了 T2 代码，所以并没有达到定时器间隔的效果\n综上所述，serInterval 有两个问题：\n-   可能多个定时器会连续执行（会导致后续的间隔误差）\n-   某些间隔会被跳过（这么设计也可能是为了尽量避免第一个问题）\n因而一般会使用 setTimeout 模拟 setInterval，来规避掉上面的缺点\n```\nsetTimeout(function fn() {\n// do something\nsetTimeout(fn, delay)\n}, delay)\n```\n这样的话，在前一个定时器代码执行完成前，不会向队列中插入新的定时器（不会连续执行），而且保证了定时器间隔\n注：有些说法，可能对当队列中存在定时器实例时，是否会跳过添加实例，存在质疑；还有的说法是，在 Node 环境中会跳过，在浏览器环境中会累加；不过我这边实测，不管在 Node 还是在 web 中，当队列中存在定时器实例时，都会跳过添加的；当然也有可能是浏览器版本或内核不同，表现不同，没有细测；感兴趣的小伙伴可以使用一下代码实测下，看是会一次性输出，还是会间隔性输出\n**这边顺便一提，涉及到做动画的场景可能会使用定时器**\n-   由于定时器的种种误差问题，以及固定时间间隔不一定与屏幕刷新时间相同，可能会引起丢帧；而且定时器在后台仍会继续执行，也会造成资源的浪费\n-   一般情况下，还是推荐使用 requestAnimationFrame，RAF 重绘或回流（重排）的时间间隔是紧紧跟随浏览器的刷新频率的；并且在页面未激活时，该页面的屏幕刷新任务也会被暂停，当页面被激活时，任务会从上次停留的地方继续执行，这也就意味着将耗费更少的资源，提升了性能\n### 总结\n-   setTimeout 和 setInterval 都存在计时误差，不会严格按照既定时间执行\n-   一般情况下，这些误差不会造成太大影响，只对于某些特殊场景，对时间要求比较严格的情况下，需要特殊处理\n-   对于 setInterval，个人建议能不用尽量不用，使用 setTimeout 的嵌套实现，可以规避掉一些潜在问题的发生\n'
      },
      {
        id: 2,
        name: '望舟',
        day: '1',
        category: '面试',
        title: '让“作用域和闭包”说人话！ ',
        intro: '让作用域和闭包说人话，面试时候有话可讲！',
        imgsrc: require('../assets/image/ArticleImg1.webp'),
        content:
        '# 一、作用域是什么\n作用域与编译原理息息相关，但是我们暂时还不用管编译原理的复杂过程，它的作用可以简单看下面这张图： \n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2dc72d14948848159ed01ab7af90a090~tplv-k3u1fbpfcp-zoom-1.image)\n简单来说就是“我得知道这些变量在哪里，不然我怎么取到它们再进行下一步操作呀！”\n***\nJavaScript的编译发生代码执行前的几微妙内，并不是发生在构建之前。\n引擎根据作用域进行变量查询，存在两种影响结果的查找方式——LHS/RHS。\nRHS（谁是源头【获取变量的值】）：需要找到这个变量的值才可以进行下一步操作。如console.log(a)，即得到a的值后执行操作。查询操作失败报ReferenceError异常，不合理操作报TypeError异常。\nLHS（目标是谁【对变量赋值】）：为操作找到一个容器，如var a = 2，即找到一个a，给它赋值为2。查询操作失败在非严格模式下会创建变量。*这个特性可以解释变量提升这个东西，也就是“赋值可以跑到声明前”。为了完成赋值这个动作，我可以自己声明一下嘛。现在可以暂时放一下这句话，等到提升时再想。*\n> ~~不推荐使用with/eval~~\n# 二、函数作用域和块作用域\n> 函数作用域含义：属于这个函数的全部变量都可以在整个函数的范围内使用或复用。\nfunction 开头的就是函数声明，其余则是函数表达式。 **正常函数声明被绑定在作用域中，函数表达式则绑定在函数自身中。** 这句话不理解可以先埋下一个伏笔，等下面看到闭包的时候再回头看会回味无穷。\n```\n// 函数声明\nfunction foo(){\nvar a = 2;\nconsole.log(a);\n}\nfoo()\n// 函数表达式\n(function foo(){\nvar a = 2;\nconsole.log(a);\n})()\nvar a = 2;\n(function IIFE(global){\nvar a = 3;\nconsole.log(a, global.a)// 3,2\n})(window)\n// 函数表达式\nvar foo = function(){\nconsole.log(1)\n}\n```\n那么怎么搞出一个块作用域呢？块作用域的声明方式有：\n1.  with 仅在with声明中有效\n1.  try/catch catch内的变量仅在catch内使用\n1.  let 劫持所在块的作用域\n1.  const 与let类似，变量不可修改\n块作用域的优势：1. 有利于垃圾回收（块作用域内代码执行后可以直接回收）；2. 解决 var 循环问题。\n# 三、提升\n> 没有赋值只有声明的变量是会报错 undefined，提升也只是提升了个声明而已；再换句话说，赋值可以跑在声明的前面。光说不干假把式~\n第一段代码可以顺利执行，因为对于 a 的声明会提升到最顶部，因此在作用域内能够找到a。但是这第二段代码中，`var a = 2;`会被拆分为两步，第一步是声明 a ，然后就执行了输出语句，还没有进行赋值呢，因此会出现报错。 这个例子恰好说明了“赋值可以跑在声明前面”。\n***\n例二：\n```\nfoo()\nfunction foo(){\nconsole.log(a); //undefined\nvar a;\n}\n```\n这里也是和例一一样，a会提升声明（作用域在foo内），但是只有声明，没有赋值，所以仍然会报错。\n***\n同样是声明提升，***函数的优先级高于变量***。这里的例子我们可以把函数表达式当作是一个变量的声明，相当于给foo2 这个变量赋值了一个函数。那么由于函数的优先级更高，这个foo2无法覆盖之前的foo1，所以输出仍然是1。\n# 四、闭包\n## 1. 闭包是什么\n首先我们得知道闭包是什么，来看看书里是怎么说的：\n> 函数在 定义时的词法作用域以外的地方 被调用，闭包使得函数可以继续访问定义时的词法作用域。\n这句话的形容使闭包看起来像一种_访问作用域的方法_。我们继续看下一句：\n> 无论通过何种手段将内部函数传递到所在的词法作用域以外，它都会持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包。\n**因此，不应该把比较理解成一种现象或者原理，应该作为一种工具方便我们使用来解决 JavaScript 中的一些问题。这是一个重要的理解点。** 用自己的话再来说一下闭包是什么吧：\n一个函数（A）引用着另一个函数的变量（B），即使 B 已经顺利执行结束了也不会被回收，因为 A 还引用着呢，所以 B 的各种变量也要被保存。\n'
      },
      {
        id: 3,
        name: 'ZEROL',
        day: '22',
        category: 'JavaScript',
        title: 'setTimeout 和 setInterval，你们两位同学注意点时间~ ',
        intro: '你们两位同学注意点时间~',
        imgsrc: require('../assets/image/ArticleImg2.webp'),
        content:
        '## 一、基本定义与用法 \n### 1、定义\n-   `setTimeout()`方法用于在指定的时间（单位毫秒）后执行回调函数或指定的一段代码\n-   `setInterval()`方法可按照指定的时间间隔（单位毫秒）来调用回调函数或指定的一段代码\n### 2、参数\n-   第一个参数 function，必填，回调函数。或者是一段字符串代码，但是这种方式不建议使用，就和使用`eval()`一样，有安全风险；而且还有作用域问题（字符串会在全局作用域内被解释执行）\n```\nsetTimeout(\'console.log(123);fn()\', 2000)\n```\n-   第二个参数 delay，可选，单位是 ms，对于`setTimeout`是延迟时间，对于`setInterval`是间隔时间，默认都是 0\n-   第三个参数 param1,param2,param3...，可选，是传递给回调函数的参数，不大常用\n ```\nsetTimeout(function (a, b) {\nconsole.log(a, b)\n}, 2000, \'我是\', \'定时器\')\n```\n### 3、返回值\n-   返回一个 ID（数字），可以将这个 ID 传递给`clearTimeout()`或`clearInterval()`来取消执行\n-   PS: `setTimeout()`和`setInterval()`共用一个编号池，技术上，`clearTimeout()`和`clearInterval()`可以互换使用，但是为了避免混淆，一般不这么做\n## 二、setTimeout 和 setInterval 的实际表现\n### 1、使用 setInterval 实现计时\n```\nconst startTime = new Date().getTime()\nlet count = 0\nconst interval = setInterval(function () {\ncount++\nconsole.log(new Date().getTime() - (startTime + count * 1000) + \'ms\')\nif(count === 10){\nclearInterval(interval);\n}\n}, 1000)\n```\n`new Date().getTime() - (startTime + count * 1000)`理想情况下应该是 0ms，然而事实并不是这样，而是存在着误差：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba8397cf6a184ed6a32b285693cff3c0~tplv-k3u1fbpfcp-zoom-1.image)\n### 2、使用 setTimeout 实现计时\n```\nconst startTime = new Date().getTime(), delay = 1000\nlet count = 0\nlet timer = setTimeout(doFunc, delay)\nfunction doFunc(){\ncount++\nconsole.log(new Date().getTime() - (startTime + count * 1000) + \'ms\')\nif(count < 10){\ntimer = setTimeout(doFunc, delay)\n}\n}\n```\nsetTimeout 也同样存在着误差，而且时间越来越大（setTimeout 需要在同步代码执行完成后才重新开始计时）：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c59850b3ac2a475eb718b5492630d88e~tplv-k3u1fbpfcp-zoom-1.image)\n## 三、为什么会出现误差\n### 1、setTimeout 的最短延迟时间\n`setTimeout`遵循的规范由 whatwg 来维护，在 [HTML Standard - 8.6 Timers](https://link.juejin.cn?target=https%3A%2F%2Fhtml.spec.whatwg.org%2Fmultipage%2Ftimers-and-user-prompts.html%23dom-settimeout "https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-settimeout") 中写到了定义定时器的详细步骤，其中有两条：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ffbfbab446fe494fb44c54181f48aa31~tplv-k3u1fbpfcp-zoom-1.image)\n上面的意思就是说，如果设置的 timeout 小于 0，则设置为 0，如果嵌套的层级超过了 5 层（计时器嵌套），并且 timeout 小于 4ms，则设置 timeout 为 4ms。并且，在不同浏览器中出现这种最小延迟的情况有所不同\n具体的源代码实现以及各大浏览器实现的不同，大家可以参考这篇文章：[为什么 setTimeout 有最小延时 4ms ？](https://link.juejin.cn?target=https%3A%2F%2Fwww.bruceyj.com%2Ffront-end-interview-summary%2Fsystem-design%2Fwhy-is-the-design%2F2-why-setTimeout-4ms.html "https://www.bruceyj.com/front-end-interview-summary/system-design/why-is-the-design/2-why-setTimeout-4ms.html")\n这里只看结论，定时器本身的定义步骤是造成其出现误差的原因之一\n### 2、setInterval 的最小间隔时间以及回调函数阻塞\n在 HTML5 标准中，setInterval 的最小间隔为 10ms，虽然我在规范文档中并未找到其相关说明，但是经过实际测试，也确实存在最小间隔时间，例如以下代码：\n```\nlet startTime = new Date().getTime()\nlet count = 0\nconst interval = setInterval(function () {\ncount++\n console.log(new Date().getTime() - startTime + \'ms\')\nstartTime = new Date().getTime()\nif(count === 10) {\nclearInterval(interval)\n}\n}, 0)\n```\n测试结果：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9bcffa807d384a7ab542fd1174186b12~tplv-k3u1fbpfcp-zoom-1.image)\n虽然没有 10ms 那么大的间隔，但是间隔仍然存在，猜测具体的间隔时间是和浏览器实现以及设备性能有关，无论如何，间隔是确实存在的\n另外，当使用 setInterval 时间间隔到点后，仅当队列中没有该定时器的任何其他代码实例时，才会将定时器的代码添加到队列中，如果有的话，则不会添加，造成堵塞，这个也与 JS 的事件循环有关\n### 3、未被激活的tabs的定时最小延迟 >= 1000ms\n为了优化后台 tab 的加载损耗（以及降低耗电量），在未被激活的 tab 中定时器的最小延时限制为1s(1000ms)，具体时间在不同的浏览器实现中也有差别\n### 4、JS 的事件循环机制\n`setTimeout`和`setInterval`中的时间并不是到点就立即执行，而是到点将其回调函数加入异步事件队列中，按照队列先进先出的性质，该回调函数到点之后是否能执行还得取决于是否属于队列首位，如果前头还有其他事件在等待，则不能按点执行，如果没有，则将其放入同步队列执行。具体事件循环机制，可以参考这篇文章：[动图学习-EventLoop](https://juejin.cn/post/6969028296893792286 "https://juejin.cn/post/6969028296893792286")\n## 四、解决方案\n### 1、在浏览器中实现一个 0ms 延时的定时器\n可以参考如下代码（来自于国外的一篇博客，也是 MDN 推荐的方法），主要是使用了 postMessage 方法，异步的执行了回调函数，并且速度要比 setTimeout(0) 要快的多。具体比较可以参照原文：[setTimeout with a shorter delay](https://link.juejin.cn?target=https%3A%2F%2Fdbaron.org%2Flog%2F20100309-faster-timeouts "https://dbaron.org/log/20100309-faster-timeouts")\n使用 setTimeout(0) 得到的时间：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8994a7da32e549cd9d06c34d1ac0bbc8~tplv-k3u1fbpfcp-zoom-1.image)\n将 setTimeout 改成 setZeroTimeout 后得到的时间，时间几乎都在 0～1，至于为什么不是绝对的 0，猜测可能与性能有关，总的来说，时间确实缩短了：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dced5471b7fc422d9f9eb28259b26ce2~tplv-k3u1fbpfcp-zoom-1.image)\n### 2、购物网站的秒杀活动\n一般情况下，从服务器拿到倒数时间后，前端的执行倒计时程序持续运行，事实上，显示时间相比实际时间会越来越慢的\n究其原因，倒计时通常是使用定时器实现，而 JS 的单线程特性使得同步任务执行过程中出现阻塞时，任务队列中的异步任务并不能及时执行，因此浏览器并不能保证在定时器设置的时间结束后代码总是被准时执行，从而造成了倒计时的偏差\n一般的解决方法是前端定时向服务器发送请求获取最新的时间差来校准倒计时时间，和用户一直按 F5 刷新没啥区别，比较简单粗暴，下面的方法可以一定程度上解决这个问题，纯前端控制，不依赖于后端。源地址已忘\n## 五、使用 setTimeout 替代 setInterval\n定时器指定的时间间隔，表示的是何时将定时器的代码添加到消息队列，而不是何时执行代码。所以真正何时执行代码的时间是不能保证的，它取决于何时被主线程的事件循环获取到，并执行\n假设有 `setInterval(function, 100)`，它的执行可能是这样的：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/30346ef998214cabb6c95141b19ad25f~tplv-k3u1fbpfcp-zoom-1.image)\n上图可见，setInterval 每隔 100ms 往队列中添加一个事件；100ms 后，添加 T1 定时器代码至队列中，主线程中还有任务在执行，所以等待，some event 执行结束后执行 T1 定时器代码；又过了100ms，T2定时器被添加到队列中，主线程还在执行 T1 代码，所以等待；又过了 100ms，理论上又要往队列里推一个定时器代码，但由于此时 T2 还在队列中，所以 T3 不会被添加，结果就是此时被跳过；然后，T1 定时器执行结束后马上执行了 T2 代码，所以并没有达到定时器间隔的效果\n综上所述，serInterval 有两个问题：\n-   可能多个定时器会连续执行（会导致后续的间隔误差）\n-   某些间隔会被跳过（这么设计也可能是为了尽量避免第一个问题）\n因而一般会使用 setTimeout 模拟 setInterval，来规避掉上面的缺点\n```\nsetTimeout(function fn() {\n// do something\nsetTimeout(fn, delay)\n}, delay)\n```\n这样的话，在前一个定时器代码执行完成前，不会向队列中插入新的定时器（不会连续执行），而且保证了定时器间隔\n注：有些说法，可能对当队列中存在定时器实例时，是否会跳过添加实例，存在质疑；还有的说法是，在 Node 环境中会跳过，在浏览器环境中会累加；不过我这边实测，不管在 Node 还是在 web 中，当队列中存在定时器实例时，都会跳过添加的；当然也有可能是浏览器版本或内核不同，表现不同，没有细测；感兴趣的小伙伴可以使用一下代码实测下，看是会一次性输出，还是会间隔性输出\n**这边顺便一提，涉及到做动画的场景可能会使用定时器**\n-   由于定时器的种种误差问题，以及固定时间间隔不一定与屏幕刷新时间相同，可能会引起丢帧；而且定时器在后台仍会继续执行，也会造成资源的浪费\n-   一般情况下，还是推荐使用 requestAnimationFrame，RAF 重绘或回流（重排）的时间间隔是紧紧跟随浏览器的刷新频率的；并且在页面未激活时，该页面的屏幕刷新任务也会被暂停，当页面被激活时，任务会从上次停留的地方继续执行，这也就意味着将耗费更少的资源，提升了性能\n### 总结\n-   setTimeout 和 setInterval 都存在计时误差，不会严格按照既定时间执行\n-   一般情况下，这些误差不会造成太大影响，只对于某些特殊场景，对时间要求比较严格的情况下，需要特殊处理\n-   对于 setInterval，个人建议能不用尽量不用，使用 setTimeout 的嵌套实现，可以规避掉一些潜在问题的发生\n'
      },
      {
        id: 4,
        name: '望舟',
        day: '1',
        category: '面试',
        title: '让“作用域和闭包”说人话！ ',
        intro: '让作用域和闭包说人话，面试时候有话可讲！',
        imgsrc: require('../assets/image/ArticleImg1.webp'),
        content:
        '# 一、作用域是什么\n作用域与编译原理息息相关，但是我们暂时还不用管编译原理的复杂过程，它的作用可以简单看下面这张图： \n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2dc72d14948848159ed01ab7af90a090~tplv-k3u1fbpfcp-zoom-1.image)\n简单来说就是“我得知道这些变量在哪里，不然我怎么取到它们再进行下一步操作呀！”\n***\nJavaScript的编译发生代码执行前的几微妙内，并不是发生在构建之前。\n引擎根据作用域进行变量查询，存在两种影响结果的查找方式——LHS/RHS。\nRHS（谁是源头【获取变量的值】）：需要找到这个变量的值才可以进行下一步操作。如console.log(a)，即得到a的值后执行操作。查询操作失败报ReferenceError异常，不合理操作报TypeError异常。\nLHS（目标是谁【对变量赋值】）：为操作找到一个容器，如var a = 2，即找到一个a，给它赋值为2。查询操作失败在非严格模式下会创建变量。*这个特性可以解释变量提升这个东西，也就是“赋值可以跑到声明前”。为了完成赋值这个动作，我可以自己声明一下嘛。现在可以暂时放一下这句话，等到提升时再想。*\n> ~~不推荐使用with/eval~~\n# 二、函数作用域和块作用域\n> 函数作用域含义：属于这个函数的全部变量都可以在整个函数的范围内使用或复用。\nfunction 开头的就是函数声明，其余则是函数表达式。 **正常函数声明被绑定在作用域中，函数表达式则绑定在函数自身中。** 这句话不理解可以先埋下一个伏笔，等下面看到闭包的时候再回头看会回味无穷。\n```\n// 函数声明\nfunction foo(){\nvar a = 2;\nconsole.log(a);\n}\nfoo()\n// 函数表达式\n(function foo(){\nvar a = 2;\nconsole.log(a);\n})()\nvar a = 2;\n(function IIFE(global){\nvar a = 3;\nconsole.log(a, global.a)// 3,2\n})(window)\n// 函数表达式\nvar foo = function(){\nconsole.log(1)\n}\n```\n那么怎么搞出一个块作用域呢？块作用域的声明方式有：\n1.  with 仅在with声明中有效\n1.  try/catch catch内的变量仅在catch内使用\n1.  let 劫持所在块的作用域\n1.  const 与let类似，变量不可修改\n块作用域的优势：1. 有利于垃圾回收（块作用域内代码执行后可以直接回收）；2. 解决 var 循环问题。\n# 三、提升\n> 没有赋值只有声明的变量是会报错 undefined，提升也只是提升了个声明而已；再换句话说，赋值可以跑在声明的前面。光说不干假把式~\n第一段代码可以顺利执行，因为对于 a 的声明会提升到最顶部，因此在作用域内能够找到a。但是这第二段代码中，`var a = 2;`会被拆分为两步，第一步是声明 a ，然后就执行了输出语句，还没有进行赋值呢，因此会出现报错。 这个例子恰好说明了“赋值可以跑在声明前面”。\n***\n例二：\n```\nfoo()\nfunction foo(){\nconsole.log(a); //undefined\nvar a;\n}\n```\n这里也是和例一一样，a会提升声明（作用域在foo内），但是只有声明，没有赋值，所以仍然会报错。\n***\n同样是声明提升，***函数的优先级高于变量***。这里的例子我们可以把函数表达式当作是一个变量的声明，相当于给foo2 这个变量赋值了一个函数。那么由于函数的优先级更高，这个foo2无法覆盖之前的foo1，所以输出仍然是1。\n# 四、闭包\n## 1. 闭包是什么\n首先我们得知道闭包是什么，来看看书里是怎么说的：\n> 函数在 定义时的词法作用域以外的地方 被调用，闭包使得函数可以继续访问定义时的词法作用域。\n这句话的形容使闭包看起来像一种_访问作用域的方法_。我们继续看下一句：\n> 无论通过何种手段将内部函数传递到所在的词法作用域以外，它都会持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包。\n**因此，不应该把比较理解成一种现象或者原理，应该作为一种工具方便我们使用来解决 JavaScript 中的一些问题。这是一个重要的理解点。** 用自己的话再来说一下闭包是什么吧：\n一个函数（A）引用着另一个函数的变量（B），即使 B 已经顺利执行结束了也不会被回收，因为 A 还引用着呢，所以 B 的各种变量也要被保存。\n'
      },
      {
        id: 5,
        name: 'ZEROL',
        day: '22',
        category: 'JavaScript',
        title: 'setTimeout 和 setInterval，你们两位同学注意点时间~ ',
        intro: '你们两位同学注意点时间~',
        imgsrc: require('../assets/image/ArticleImg2.webp'),
        content:
        '## 一、基本定义与用法 \n### 1、定义\n-   `setTimeout()`方法用于在指定的时间（单位毫秒）后执行回调函数或指定的一段代码\n-   `setInterval()`方法可按照指定的时间间隔（单位毫秒）来调用回调函数或指定的一段代码\n### 2、参数\n-   第一个参数 function，必填，回调函数。或者是一段字符串代码，但是这种方式不建议使用，就和使用`eval()`一样，有安全风险；而且还有作用域问题（字符串会在全局作用域内被解释执行）\n```\nsetTimeout(\'console.log(123);fn()\', 2000)\n```\n-   第二个参数 delay，可选，单位是 ms，对于`setTimeout`是延迟时间，对于`setInterval`是间隔时间，默认都是 0\n-   第三个参数 param1,param2,param3...，可选，是传递给回调函数的参数，不大常用\n ```\nsetTimeout(function (a, b) {\nconsole.log(a, b)\n}, 2000, \'我是\', \'定时器\')\n```\n### 3、返回值\n-   返回一个 ID（数字），可以将这个 ID 传递给`clearTimeout()`或`clearInterval()`来取消执行\n-   PS: `setTimeout()`和`setInterval()`共用一个编号池，技术上，`clearTimeout()`和`clearInterval()`可以互换使用，但是为了避免混淆，一般不这么做\n## 二、setTimeout 和 setInterval 的实际表现\n### 1、使用 setInterval 实现计时\n```\nconst startTime = new Date().getTime()\nlet count = 0\nconst interval = setInterval(function () {\ncount++\nconsole.log(new Date().getTime() - (startTime + count * 1000) + \'ms\')\nif(count === 10){\nclearInterval(interval);\n}\n}, 1000)\n```\n`new Date().getTime() - (startTime + count * 1000)`理想情况下应该是 0ms，然而事实并不是这样，而是存在着误差：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba8397cf6a184ed6a32b285693cff3c0~tplv-k3u1fbpfcp-zoom-1.image)\n### 2、使用 setTimeout 实现计时\n```\nconst startTime = new Date().getTime(), delay = 1000\nlet count = 0\nlet timer = setTimeout(doFunc, delay)\nfunction doFunc(){\ncount++\nconsole.log(new Date().getTime() - (startTime + count * 1000) + \'ms\')\nif(count < 10){\ntimer = setTimeout(doFunc, delay)\n}\n}\n```\nsetTimeout 也同样存在着误差，而且时间越来越大（setTimeout 需要在同步代码执行完成后才重新开始计时）：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c59850b3ac2a475eb718b5492630d88e~tplv-k3u1fbpfcp-zoom-1.image)\n## 三、为什么会出现误差\n### 1、setTimeout 的最短延迟时间\n`setTimeout`遵循的规范由 whatwg 来维护，在 [HTML Standard - 8.6 Timers](https://link.juejin.cn?target=https%3A%2F%2Fhtml.spec.whatwg.org%2Fmultipage%2Ftimers-and-user-prompts.html%23dom-settimeout "https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-settimeout") 中写到了定义定时器的详细步骤，其中有两条：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ffbfbab446fe494fb44c54181f48aa31~tplv-k3u1fbpfcp-zoom-1.image)\n上面的意思就是说，如果设置的 timeout 小于 0，则设置为 0，如果嵌套的层级超过了 5 层（计时器嵌套），并且 timeout 小于 4ms，则设置 timeout 为 4ms。并且，在不同浏览器中出现这种最小延迟的情况有所不同\n具体的源代码实现以及各大浏览器实现的不同，大家可以参考这篇文章：[为什么 setTimeout 有最小延时 4ms ？](https://link.juejin.cn?target=https%3A%2F%2Fwww.bruceyj.com%2Ffront-end-interview-summary%2Fsystem-design%2Fwhy-is-the-design%2F2-why-setTimeout-4ms.html "https://www.bruceyj.com/front-end-interview-summary/system-design/why-is-the-design/2-why-setTimeout-4ms.html")\n这里只看结论，定时器本身的定义步骤是造成其出现误差的原因之一\n### 2、setInterval 的最小间隔时间以及回调函数阻塞\n在 HTML5 标准中，setInterval 的最小间隔为 10ms，虽然我在规范文档中并未找到其相关说明，但是经过实际测试，也确实存在最小间隔时间，例如以下代码：\n```\nlet startTime = new Date().getTime()\nlet count = 0\nconst interval = setInterval(function () {\ncount++\n console.log(new Date().getTime() - startTime + \'ms\')\nstartTime = new Date().getTime()\nif(count === 10) {\nclearInterval(interval)\n}\n}, 0)\n```\n测试结果：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9bcffa807d384a7ab542fd1174186b12~tplv-k3u1fbpfcp-zoom-1.image)\n虽然没有 10ms 那么大的间隔，但是间隔仍然存在，猜测具体的间隔时间是和浏览器实现以及设备性能有关，无论如何，间隔是确实存在的\n另外，当使用 setInterval 时间间隔到点后，仅当队列中没有该定时器的任何其他代码实例时，才会将定时器的代码添加到队列中，如果有的话，则不会添加，造成堵塞，这个也与 JS 的事件循环有关\n### 3、未被激活的tabs的定时最小延迟 >= 1000ms\n为了优化后台 tab 的加载损耗（以及降低耗电量），在未被激活的 tab 中定时器的最小延时限制为1s(1000ms)，具体时间在不同的浏览器实现中也有差别\n### 4、JS 的事件循环机制\n`setTimeout`和`setInterval`中的时间并不是到点就立即执行，而是到点将其回调函数加入异步事件队列中，按照队列先进先出的性质，该回调函数到点之后是否能执行还得取决于是否属于队列首位，如果前头还有其他事件在等待，则不能按点执行，如果没有，则将其放入同步队列执行。具体事件循环机制，可以参考这篇文章：[动图学习-EventLoop](https://juejin.cn/post/6969028296893792286 "https://juejin.cn/post/6969028296893792286")\n## 四、解决方案\n### 1、在浏览器中实现一个 0ms 延时的定时器\n可以参考如下代码（来自于国外的一篇博客，也是 MDN 推荐的方法），主要是使用了 postMessage 方法，异步的执行了回调函数，并且速度要比 setTimeout(0) 要快的多。具体比较可以参照原文：[setTimeout with a shorter delay](https://link.juejin.cn?target=https%3A%2F%2Fdbaron.org%2Flog%2F20100309-faster-timeouts "https://dbaron.org/log/20100309-faster-timeouts")\n使用 setTimeout(0) 得到的时间：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8994a7da32e549cd9d06c34d1ac0bbc8~tplv-k3u1fbpfcp-zoom-1.image)\n将 setTimeout 改成 setZeroTimeout 后得到的时间，时间几乎都在 0～1，至于为什么不是绝对的 0，猜测可能与性能有关，总的来说，时间确实缩短了：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dced5471b7fc422d9f9eb28259b26ce2~tplv-k3u1fbpfcp-zoom-1.image)\n### 2、购物网站的秒杀活动\n一般情况下，从服务器拿到倒数时间后，前端的执行倒计时程序持续运行，事实上，显示时间相比实际时间会越来越慢的\n究其原因，倒计时通常是使用定时器实现，而 JS 的单线程特性使得同步任务执行过程中出现阻塞时，任务队列中的异步任务并不能及时执行，因此浏览器并不能保证在定时器设置的时间结束后代码总是被准时执行，从而造成了倒计时的偏差\n一般的解决方法是前端定时向服务器发送请求获取最新的时间差来校准倒计时时间，和用户一直按 F5 刷新没啥区别，比较简单粗暴，下面的方法可以一定程度上解决这个问题，纯前端控制，不依赖于后端。源地址已忘\n## 五、使用 setTimeout 替代 setInterval\n定时器指定的时间间隔，表示的是何时将定时器的代码添加到消息队列，而不是何时执行代码。所以真正何时执行代码的时间是不能保证的，它取决于何时被主线程的事件循环获取到，并执行\n假设有 `setInterval(function, 100)`，它的执行可能是这样的：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/30346ef998214cabb6c95141b19ad25f~tplv-k3u1fbpfcp-zoom-1.image)\n上图可见，setInterval 每隔 100ms 往队列中添加一个事件；100ms 后，添加 T1 定时器代码至队列中，主线程中还有任务在执行，所以等待，some event 执行结束后执行 T1 定时器代码；又过了100ms，T2定时器被添加到队列中，主线程还在执行 T1 代码，所以等待；又过了 100ms，理论上又要往队列里推一个定时器代码，但由于此时 T2 还在队列中，所以 T3 不会被添加，结果就是此时被跳过；然后，T1 定时器执行结束后马上执行了 T2 代码，所以并没有达到定时器间隔的效果\n综上所述，serInterval 有两个问题：\n-   可能多个定时器会连续执行（会导致后续的间隔误差）\n-   某些间隔会被跳过（这么设计也可能是为了尽量避免第一个问题）\n因而一般会使用 setTimeout 模拟 setInterval，来规避掉上面的缺点\n```\nsetTimeout(function fn() {\n// do something\nsetTimeout(fn, delay)\n}, delay)\n```\n这样的话，在前一个定时器代码执行完成前，不会向队列中插入新的定时器（不会连续执行），而且保证了定时器间隔\n注：有些说法，可能对当队列中存在定时器实例时，是否会跳过添加实例，存在质疑；还有的说法是，在 Node 环境中会跳过，在浏览器环境中会累加；不过我这边实测，不管在 Node 还是在 web 中，当队列中存在定时器实例时，都会跳过添加的；当然也有可能是浏览器版本或内核不同，表现不同，没有细测；感兴趣的小伙伴可以使用一下代码实测下，看是会一次性输出，还是会间隔性输出\n**这边顺便一提，涉及到做动画的场景可能会使用定时器**\n-   由于定时器的种种误差问题，以及固定时间间隔不一定与屏幕刷新时间相同，可能会引起丢帧；而且定时器在后台仍会继续执行，也会造成资源的浪费\n-   一般情况下，还是推荐使用 requestAnimationFrame，RAF 重绘或回流（重排）的时间间隔是紧紧跟随浏览器的刷新频率的；并且在页面未激活时，该页面的屏幕刷新任务也会被暂停，当页面被激活时，任务会从上次停留的地方继续执行，这也就意味着将耗费更少的资源，提升了性能\n### 总结\n-   setTimeout 和 setInterval 都存在计时误差，不会严格按照既定时间执行\n-   一般情况下，这些误差不会造成太大影响，只对于某些特殊场景，对时间要求比较严格的情况下，需要特殊处理\n-   对于 setInterval，个人建议能不用尽量不用，使用 setTimeout 的嵌套实现，可以规避掉一些潜在问题的发生\n'
      },{
        id: 6,
        name: 'ZEROL',
        day: '22',
        category: 'JavaScript',
        title: 'setTimeout 和 setInterval，你们两位同学注意点时间~ ',
        intro: '你们两位同学注意点时间~',
        imgsrc: require('../assets/image/ArticleImg2.webp'),
        content:
        '## 一、基本定义与用法 \n### 1、定义\n-   `setTimeout()`方法用于在指定的时间（单位毫秒）后执行回调函数或指定的一段代码\n-   `setInterval()`方法可按照指定的时间间隔（单位毫秒）来调用回调函数或指定的一段代码\n### 2、参数\n-   第一个参数 function，必填，回调函数。或者是一段字符串代码，但是这种方式不建议使用，就和使用`eval()`一样，有安全风险；而且还有作用域问题（字符串会在全局作用域内被解释执行）\n```\nsetTimeout(\'console.log(123);fn()\', 2000)\n```\n-   第二个参数 delay，可选，单位是 ms，对于`setTimeout`是延迟时间，对于`setInterval`是间隔时间，默认都是 0\n-   第三个参数 param1,param2,param3...，可选，是传递给回调函数的参数，不大常用\n ```\nsetTimeout(function (a, b) {\nconsole.log(a, b)\n}, 2000, \'我是\', \'定时器\')\n```\n### 3、返回值\n-   返回一个 ID（数字），可以将这个 ID 传递给`clearTimeout()`或`clearInterval()`来取消执行\n-   PS: `setTimeout()`和`setInterval()`共用一个编号池，技术上，`clearTimeout()`和`clearInterval()`可以互换使用，但是为了避免混淆，一般不这么做\n## 二、setTimeout 和 setInterval 的实际表现\n### 1、使用 setInterval 实现计时\n```\nconst startTime = new Date().getTime()\nlet count = 0\nconst interval = setInterval(function () {\ncount++\nconsole.log(new Date().getTime() - (startTime + count * 1000) + \'ms\')\nif(count === 10){\nclearInterval(interval);\n}\n}, 1000)\n```\n`new Date().getTime() - (startTime + count * 1000)`理想情况下应该是 0ms，然而事实并不是这样，而是存在着误差：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba8397cf6a184ed6a32b285693cff3c0~tplv-k3u1fbpfcp-zoom-1.image)\n### 2、使用 setTimeout 实现计时\n```\nconst startTime = new Date().getTime(), delay = 1000\nlet count = 0\nlet timer = setTimeout(doFunc, delay)\nfunction doFunc(){\ncount++\nconsole.log(new Date().getTime() - (startTime + count * 1000) + \'ms\')\nif(count < 10){\ntimer = setTimeout(doFunc, delay)\n}\n}\n```\nsetTimeout 也同样存在着误差，而且时间越来越大（setTimeout 需要在同步代码执行完成后才重新开始计时）：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c59850b3ac2a475eb718b5492630d88e~tplv-k3u1fbpfcp-zoom-1.image)\n## 三、为什么会出现误差\n### 1、setTimeout 的最短延迟时间\n`setTimeout`遵循的规范由 whatwg 来维护，在 [HTML Standard - 8.6 Timers](https://link.juejin.cn?target=https%3A%2F%2Fhtml.spec.whatwg.org%2Fmultipage%2Ftimers-and-user-prompts.html%23dom-settimeout "https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-settimeout") 中写到了定义定时器的详细步骤，其中有两条：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ffbfbab446fe494fb44c54181f48aa31~tplv-k3u1fbpfcp-zoom-1.image)\n上面的意思就是说，如果设置的 timeout 小于 0，则设置为 0，如果嵌套的层级超过了 5 层（计时器嵌套），并且 timeout 小于 4ms，则设置 timeout 为 4ms。并且，在不同浏览器中出现这种最小延迟的情况有所不同\n具体的源代码实现以及各大浏览器实现的不同，大家可以参考这篇文章：[为什么 setTimeout 有最小延时 4ms ？](https://link.juejin.cn?target=https%3A%2F%2Fwww.bruceyj.com%2Ffront-end-interview-summary%2Fsystem-design%2Fwhy-is-the-design%2F2-why-setTimeout-4ms.html "https://www.bruceyj.com/front-end-interview-summary/system-design/why-is-the-design/2-why-setTimeout-4ms.html")\n这里只看结论，定时器本身的定义步骤是造成其出现误差的原因之一\n### 2、setInterval 的最小间隔时间以及回调函数阻塞\n在 HTML5 标准中，setInterval 的最小间隔为 10ms，虽然我在规范文档中并未找到其相关说明，但是经过实际测试，也确实存在最小间隔时间，例如以下代码：\n```\nlet startTime = new Date().getTime()\nlet count = 0\nconst interval = setInterval(function () {\ncount++\n console.log(new Date().getTime() - startTime + \'ms\')\nstartTime = new Date().getTime()\nif(count === 10) {\nclearInterval(interval)\n}\n}, 0)\n```\n测试结果：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9bcffa807d384a7ab542fd1174186b12~tplv-k3u1fbpfcp-zoom-1.image)\n虽然没有 10ms 那么大的间隔，但是间隔仍然存在，猜测具体的间隔时间是和浏览器实现以及设备性能有关，无论如何，间隔是确实存在的\n另外，当使用 setInterval 时间间隔到点后，仅当队列中没有该定时器的任何其他代码实例时，才会将定时器的代码添加到队列中，如果有的话，则不会添加，造成堵塞，这个也与 JS 的事件循环有关\n### 3、未被激活的tabs的定时最小延迟 >= 1000ms\n为了优化后台 tab 的加载损耗（以及降低耗电量），在未被激活的 tab 中定时器的最小延时限制为1s(1000ms)，具体时间在不同的浏览器实现中也有差别\n### 4、JS 的事件循环机制\n`setTimeout`和`setInterval`中的时间并不是到点就立即执行，而是到点将其回调函数加入异步事件队列中，按照队列先进先出的性质，该回调函数到点之后是否能执行还得取决于是否属于队列首位，如果前头还有其他事件在等待，则不能按点执行，如果没有，则将其放入同步队列执行。具体事件循环机制，可以参考这篇文章：[动图学习-EventLoop](https://juejin.cn/post/6969028296893792286 "https://juejin.cn/post/6969028296893792286")\n## 四、解决方案\n### 1、在浏览器中实现一个 0ms 延时的定时器\n可以参考如下代码（来自于国外的一篇博客，也是 MDN 推荐的方法），主要是使用了 postMessage 方法，异步的执行了回调函数，并且速度要比 setTimeout(0) 要快的多。具体比较可以参照原文：[setTimeout with a shorter delay](https://link.juejin.cn?target=https%3A%2F%2Fdbaron.org%2Flog%2F20100309-faster-timeouts "https://dbaron.org/log/20100309-faster-timeouts")\n使用 setTimeout(0) 得到的时间：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8994a7da32e549cd9d06c34d1ac0bbc8~tplv-k3u1fbpfcp-zoom-1.image)\n将 setTimeout 改成 setZeroTimeout 后得到的时间，时间几乎都在 0～1，至于为什么不是绝对的 0，猜测可能与性能有关，总的来说，时间确实缩短了：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dced5471b7fc422d9f9eb28259b26ce2~tplv-k3u1fbpfcp-zoom-1.image)\n### 2、购物网站的秒杀活动\n一般情况下，从服务器拿到倒数时间后，前端的执行倒计时程序持续运行，事实上，显示时间相比实际时间会越来越慢的\n究其原因，倒计时通常是使用定时器实现，而 JS 的单线程特性使得同步任务执行过程中出现阻塞时，任务队列中的异步任务并不能及时执行，因此浏览器并不能保证在定时器设置的时间结束后代码总是被准时执行，从而造成了倒计时的偏差\n一般的解决方法是前端定时向服务器发送请求获取最新的时间差来校准倒计时时间，和用户一直按 F5 刷新没啥区别，比较简单粗暴，下面的方法可以一定程度上解决这个问题，纯前端控制，不依赖于后端。源地址已忘\n## 五、使用 setTimeout 替代 setInterval\n定时器指定的时间间隔，表示的是何时将定时器的代码添加到消息队列，而不是何时执行代码。所以真正何时执行代码的时间是不能保证的，它取决于何时被主线程的事件循环获取到，并执行\n假设有 `setInterval(function, 100)`，它的执行可能是这样的：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/30346ef998214cabb6c95141b19ad25f~tplv-k3u1fbpfcp-zoom-1.image)\n上图可见，setInterval 每隔 100ms 往队列中添加一个事件；100ms 后，添加 T1 定时器代码至队列中，主线程中还有任务在执行，所以等待，some event 执行结束后执行 T1 定时器代码；又过了100ms，T2定时器被添加到队列中，主线程还在执行 T1 代码，所以等待；又过了 100ms，理论上又要往队列里推一个定时器代码，但由于此时 T2 还在队列中，所以 T3 不会被添加，结果就是此时被跳过；然后，T1 定时器执行结束后马上执行了 T2 代码，所以并没有达到定时器间隔的效果\n综上所述，serInterval 有两个问题：\n-   可能多个定时器会连续执行（会导致后续的间隔误差）\n-   某些间隔会被跳过（这么设计也可能是为了尽量避免第一个问题）\n因而一般会使用 setTimeout 模拟 setInterval，来规避掉上面的缺点\n```\nsetTimeout(function fn() {\n// do something\nsetTimeout(fn, delay)\n}, delay)\n```\n这样的话，在前一个定时器代码执行完成前，不会向队列中插入新的定时器（不会连续执行），而且保证了定时器间隔\n注：有些说法，可能对当队列中存在定时器实例时，是否会跳过添加实例，存在质疑；还有的说法是，在 Node 环境中会跳过，在浏览器环境中会累加；不过我这边实测，不管在 Node 还是在 web 中，当队列中存在定时器实例时，都会跳过添加的；当然也有可能是浏览器版本或内核不同，表现不同，没有细测；感兴趣的小伙伴可以使用一下代码实测下，看是会一次性输出，还是会间隔性输出\n**这边顺便一提，涉及到做动画的场景可能会使用定时器**\n-   由于定时器的种种误差问题，以及固定时间间隔不一定与屏幕刷新时间相同，可能会引起丢帧；而且定时器在后台仍会继续执行，也会造成资源的浪费\n-   一般情况下，还是推荐使用 requestAnimationFrame，RAF 重绘或回流（重排）的时间间隔是紧紧跟随浏览器的刷新频率的；并且在页面未激活时，该页面的屏幕刷新任务也会被暂停，当页面被激活时，任务会从上次停留的地方继续执行，这也就意味着将耗费更少的资源，提升了性能\n### 总结\n-   setTimeout 和 setInterval 都存在计时误差，不会严格按照既定时间执行\n-   一般情况下，这些误差不会造成太大影响，只对于某些特殊场景，对时间要求比较严格的情况下，需要特殊处理\n-   对于 setInterval，个人建议能不用尽量不用，使用 setTimeout 的嵌套实现，可以规避掉一些潜在问题的发生\n'
      },{
        id: 7,
        name: 'ZEROL',
        day: '22',
        category: 'JavaScript',
        title: 'setTimeout 和 setInterval，你们两位同学注意点时间~ ',
        intro: '你们两位同学注意点时间~',
        imgsrc: require('../assets/image/ArticleImg2.webp'),
        content:
        '## 一、基本定义与用法 \n### 1、定义\n-   `setTimeout()`方法用于在指定的时间（单位毫秒）后执行回调函数或指定的一段代码\n-   `setInterval()`方法可按照指定的时间间隔（单位毫秒）来调用回调函数或指定的一段代码\n### 2、参数\n-   第一个参数 function，必填，回调函数。或者是一段字符串代码，但是这种方式不建议使用，就和使用`eval()`一样，有安全风险；而且还有作用域问题（字符串会在全局作用域内被解释执行）\n```\nsetTimeout(\'console.log(123);fn()\', 2000)\n```\n-   第二个参数 delay，可选，单位是 ms，对于`setTimeout`是延迟时间，对于`setInterval`是间隔时间，默认都是 0\n-   第三个参数 param1,param2,param3...，可选，是传递给回调函数的参数，不大常用\n ```\nsetTimeout(function (a, b) {\nconsole.log(a, b)\n}, 2000, \'我是\', \'定时器\')\n```\n### 3、返回值\n-   返回一个 ID（数字），可以将这个 ID 传递给`clearTimeout()`或`clearInterval()`来取消执行\n-   PS: `setTimeout()`和`setInterval()`共用一个编号池，技术上，`clearTimeout()`和`clearInterval()`可以互换使用，但是为了避免混淆，一般不这么做\n## 二、setTimeout 和 setInterval 的实际表现\n### 1、使用 setInterval 实现计时\n```\nconst startTime = new Date().getTime()\nlet count = 0\nconst interval = setInterval(function () {\ncount++\nconsole.log(new Date().getTime() - (startTime + count * 1000) + \'ms\')\nif(count === 10){\nclearInterval(interval);\n}\n}, 1000)\n```\n`new Date().getTime() - (startTime + count * 1000)`理想情况下应该是 0ms，然而事实并不是这样，而是存在着误差：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba8397cf6a184ed6a32b285693cff3c0~tplv-k3u1fbpfcp-zoom-1.image)\n### 2、使用 setTimeout 实现计时\n```\nconst startTime = new Date().getTime(), delay = 1000\nlet count = 0\nlet timer = setTimeout(doFunc, delay)\nfunction doFunc(){\ncount++\nconsole.log(new Date().getTime() - (startTime + count * 1000) + \'ms\')\nif(count < 10){\ntimer = setTimeout(doFunc, delay)\n}\n}\n```\nsetTimeout 也同样存在着误差，而且时间越来越大（setTimeout 需要在同步代码执行完成后才重新开始计时）：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c59850b3ac2a475eb718b5492630d88e~tplv-k3u1fbpfcp-zoom-1.image)\n## 三、为什么会出现误差\n### 1、setTimeout 的最短延迟时间\n`setTimeout`遵循的规范由 whatwg 来维护，在 [HTML Standard - 8.6 Timers](https://link.juejin.cn?target=https%3A%2F%2Fhtml.spec.whatwg.org%2Fmultipage%2Ftimers-and-user-prompts.html%23dom-settimeout "https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-settimeout") 中写到了定义定时器的详细步骤，其中有两条：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ffbfbab446fe494fb44c54181f48aa31~tplv-k3u1fbpfcp-zoom-1.image)\n上面的意思就是说，如果设置的 timeout 小于 0，则设置为 0，如果嵌套的层级超过了 5 层（计时器嵌套），并且 timeout 小于 4ms，则设置 timeout 为 4ms。并且，在不同浏览器中出现这种最小延迟的情况有所不同\n具体的源代码实现以及各大浏览器实现的不同，大家可以参考这篇文章：[为什么 setTimeout 有最小延时 4ms ？](https://link.juejin.cn?target=https%3A%2F%2Fwww.bruceyj.com%2Ffront-end-interview-summary%2Fsystem-design%2Fwhy-is-the-design%2F2-why-setTimeout-4ms.html "https://www.bruceyj.com/front-end-interview-summary/system-design/why-is-the-design/2-why-setTimeout-4ms.html")\n这里只看结论，定时器本身的定义步骤是造成其出现误差的原因之一\n### 2、setInterval 的最小间隔时间以及回调函数阻塞\n在 HTML5 标准中，setInterval 的最小间隔为 10ms，虽然我在规范文档中并未找到其相关说明，但是经过实际测试，也确实存在最小间隔时间，例如以下代码：\n```\nlet startTime = new Date().getTime()\nlet count = 0\nconst interval = setInterval(function () {\ncount++\n console.log(new Date().getTime() - startTime + \'ms\')\nstartTime = new Date().getTime()\nif(count === 10) {\nclearInterval(interval)\n}\n}, 0)\n```\n测试结果：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9bcffa807d384a7ab542fd1174186b12~tplv-k3u1fbpfcp-zoom-1.image)\n虽然没有 10ms 那么大的间隔，但是间隔仍然存在，猜测具体的间隔时间是和浏览器实现以及设备性能有关，无论如何，间隔是确实存在的\n另外，当使用 setInterval 时间间隔到点后，仅当队列中没有该定时器的任何其他代码实例时，才会将定时器的代码添加到队列中，如果有的话，则不会添加，造成堵塞，这个也与 JS 的事件循环有关\n### 3、未被激活的tabs的定时最小延迟 >= 1000ms\n为了优化后台 tab 的加载损耗（以及降低耗电量），在未被激活的 tab 中定时器的最小延时限制为1s(1000ms)，具体时间在不同的浏览器实现中也有差别\n### 4、JS 的事件循环机制\n`setTimeout`和`setInterval`中的时间并不是到点就立即执行，而是到点将其回调函数加入异步事件队列中，按照队列先进先出的性质，该回调函数到点之后是否能执行还得取决于是否属于队列首位，如果前头还有其他事件在等待，则不能按点执行，如果没有，则将其放入同步队列执行。具体事件循环机制，可以参考这篇文章：[动图学习-EventLoop](https://juejin.cn/post/6969028296893792286 "https://juejin.cn/post/6969028296893792286")\n## 四、解决方案\n### 1、在浏览器中实现一个 0ms 延时的定时器\n可以参考如下代码（来自于国外的一篇博客，也是 MDN 推荐的方法），主要是使用了 postMessage 方法，异步的执行了回调函数，并且速度要比 setTimeout(0) 要快的多。具体比较可以参照原文：[setTimeout with a shorter delay](https://link.juejin.cn?target=https%3A%2F%2Fdbaron.org%2Flog%2F20100309-faster-timeouts "https://dbaron.org/log/20100309-faster-timeouts")\n使用 setTimeout(0) 得到的时间：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8994a7da32e549cd9d06c34d1ac0bbc8~tplv-k3u1fbpfcp-zoom-1.image)\n将 setTimeout 改成 setZeroTimeout 后得到的时间，时间几乎都在 0～1，至于为什么不是绝对的 0，猜测可能与性能有关，总的来说，时间确实缩短了：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dced5471b7fc422d9f9eb28259b26ce2~tplv-k3u1fbpfcp-zoom-1.image)\n### 2、购物网站的秒杀活动\n一般情况下，从服务器拿到倒数时间后，前端的执行倒计时程序持续运行，事实上，显示时间相比实际时间会越来越慢的\n究其原因，倒计时通常是使用定时器实现，而 JS 的单线程特性使得同步任务执行过程中出现阻塞时，任务队列中的异步任务并不能及时执行，因此浏览器并不能保证在定时器设置的时间结束后代码总是被准时执行，从而造成了倒计时的偏差\n一般的解决方法是前端定时向服务器发送请求获取最新的时间差来校准倒计时时间，和用户一直按 F5 刷新没啥区别，比较简单粗暴，下面的方法可以一定程度上解决这个问题，纯前端控制，不依赖于后端。源地址已忘\n## 五、使用 setTimeout 替代 setInterval\n定时器指定的时间间隔，表示的是何时将定时器的代码添加到消息队列，而不是何时执行代码。所以真正何时执行代码的时间是不能保证的，它取决于何时被主线程的事件循环获取到，并执行\n假设有 `setInterval(function, 100)`，它的执行可能是这样的：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/30346ef998214cabb6c95141b19ad25f~tplv-k3u1fbpfcp-zoom-1.image)\n上图可见，setInterval 每隔 100ms 往队列中添加一个事件；100ms 后，添加 T1 定时器代码至队列中，主线程中还有任务在执行，所以等待，some event 执行结束后执行 T1 定时器代码；又过了100ms，T2定时器被添加到队列中，主线程还在执行 T1 代码，所以等待；又过了 100ms，理论上又要往队列里推一个定时器代码，但由于此时 T2 还在队列中，所以 T3 不会被添加，结果就是此时被跳过；然后，T1 定时器执行结束后马上执行了 T2 代码，所以并没有达到定时器间隔的效果\n综上所述，serInterval 有两个问题：\n-   可能多个定时器会连续执行（会导致后续的间隔误差）\n-   某些间隔会被跳过（这么设计也可能是为了尽量避免第一个问题）\n因而一般会使用 setTimeout 模拟 setInterval，来规避掉上面的缺点\n```\nsetTimeout(function fn() {\n// do something\nsetTimeout(fn, delay)\n}, delay)\n```\n这样的话，在前一个定时器代码执行完成前，不会向队列中插入新的定时器（不会连续执行），而且保证了定时器间隔\n注：有些说法，可能对当队列中存在定时器实例时，是否会跳过添加实例，存在质疑；还有的说法是，在 Node 环境中会跳过，在浏览器环境中会累加；不过我这边实测，不管在 Node 还是在 web 中，当队列中存在定时器实例时，都会跳过添加的；当然也有可能是浏览器版本或内核不同，表现不同，没有细测；感兴趣的小伙伴可以使用一下代码实测下，看是会一次性输出，还是会间隔性输出\n**这边顺便一提，涉及到做动画的场景可能会使用定时器**\n-   由于定时器的种种误差问题，以及固定时间间隔不一定与屏幕刷新时间相同，可能会引起丢帧；而且定时器在后台仍会继续执行，也会造成资源的浪费\n-   一般情况下，还是推荐使用 requestAnimationFrame，RAF 重绘或回流（重排）的时间间隔是紧紧跟随浏览器的刷新频率的；并且在页面未激活时，该页面的屏幕刷新任务也会被暂停，当页面被激活时，任务会从上次停留的地方继续执行，这也就意味着将耗费更少的资源，提升了性能\n### 总结\n-   setTimeout 和 setInterval 都存在计时误差，不会严格按照既定时间执行\n-   一般情况下，这些误差不会造成太大影响，只对于某些特殊场景，对时间要求比较严格的情况下，需要特殊处理\n-   对于 setInterval，个人建议能不用尽量不用，使用 setTimeout 的嵌套实现，可以规避掉一些潜在问题的发生\n'
      },{
        id: 8,
        name: '望舟',
        day: '1',
        category: '面试',
        title: '让“作用域和闭包”说人话！ ',
        intro: '让作用域和闭包说人话，面试时候有话可讲！',
        imgsrc: require('../assets/image/ArticleImg1.webp'),
        content:
        '# 一、作用域是什么\n作用域与编译原理息息相关，但是我们暂时还不用管编译原理的复杂过程，它的作用可以简单看下面这张图： \n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2dc72d14948848159ed01ab7af90a090~tplv-k3u1fbpfcp-zoom-1.image)\n简单来说就是“我得知道这些变量在哪里，不然我怎么取到它们再进行下一步操作呀！”\n***\nJavaScript的编译发生代码执行前的几微妙内，并不是发生在构建之前。\n引擎根据作用域进行变量查询，存在两种影响结果的查找方式——LHS/RHS。\nRHS（谁是源头【获取变量的值】）：需要找到这个变量的值才可以进行下一步操作。如console.log(a)，即得到a的值后执行操作。查询操作失败报ReferenceError异常，不合理操作报TypeError异常。\nLHS（目标是谁【对变量赋值】）：为操作找到一个容器，如var a = 2，即找到一个a，给它赋值为2。查询操作失败在非严格模式下会创建变量。*这个特性可以解释变量提升这个东西，也就是“赋值可以跑到声明前”。为了完成赋值这个动作，我可以自己声明一下嘛。现在可以暂时放一下这句话，等到提升时再想。*\n> ~~不推荐使用with/eval~~\n# 二、函数作用域和块作用域\n> 函数作用域含义：属于这个函数的全部变量都可以在整个函数的范围内使用或复用。\nfunction 开头的就是函数声明，其余则是函数表达式。 **正常函数声明被绑定在作用域中，函数表达式则绑定在函数自身中。** 这句话不理解可以先埋下一个伏笔，等下面看到闭包的时候再回头看会回味无穷。\n```\n// 函数声明\nfunction foo(){\nvar a = 2;\nconsole.log(a);\n}\nfoo()\n// 函数表达式\n(function foo(){\nvar a = 2;\nconsole.log(a);\n})()\nvar a = 2;\n(function IIFE(global){\nvar a = 3;\nconsole.log(a, global.a)// 3,2\n})(window)\n// 函数表达式\nvar foo = function(){\nconsole.log(1)\n}\n```\n那么怎么搞出一个块作用域呢？块作用域的声明方式有：\n1.  with 仅在with声明中有效\n1.  try/catch catch内的变量仅在catch内使用\n1.  let 劫持所在块的作用域\n1.  const 与let类似，变量不可修改\n块作用域的优势：1. 有利于垃圾回收（块作用域内代码执行后可以直接回收）；2. 解决 var 循环问题。\n# 三、提升\n> 没有赋值只有声明的变量是会报错 undefined，提升也只是提升了个声明而已；再换句话说，赋值可以跑在声明的前面。光说不干假把式~\n第一段代码可以顺利执行，因为对于 a 的声明会提升到最顶部，因此在作用域内能够找到a。但是这第二段代码中，`var a = 2;`会被拆分为两步，第一步是声明 a ，然后就执行了输出语句，还没有进行赋值呢，因此会出现报错。 这个例子恰好说明了“赋值可以跑在声明前面”。\n***\n例二：\n```\nfoo()\nfunction foo(){\nconsole.log(a); //undefined\nvar a;\n}\n```\n这里也是和例一一样，a会提升声明（作用域在foo内），但是只有声明，没有赋值，所以仍然会报错。\n***\n同样是声明提升，***函数的优先级高于变量***。这里的例子我们可以把函数表达式当作是一个变量的声明，相当于给foo2 这个变量赋值了一个函数。那么由于函数的优先级更高，这个foo2无法覆盖之前的foo1，所以输出仍然是1。\n# 四、闭包\n## 1. 闭包是什么\n首先我们得知道闭包是什么，来看看书里是怎么说的：\n> 函数在 定义时的词法作用域以外的地方 被调用，闭包使得函数可以继续访问定义时的词法作用域。\n这句话的形容使闭包看起来像一种_访问作用域的方法_。我们继续看下一句：\n> 无论通过何种手段将内部函数传递到所在的词法作用域以外，它都会持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包。\n**因此，不应该把比较理解成一种现象或者原理，应该作为一种工具方便我们使用来解决 JavaScript 中的一些问题。这是一个重要的理解点。** 用自己的话再来说一下闭包是什么吧：\n一个函数（A）引用着另一个函数的变量（B），即使 B 已经顺利执行结束了也不会被回收，因为 A 还引用着呢，所以 B 的各种变量也要被保存。\n'
      },{
        id: 9,
        name: 'ZEROL',
        day: '22',
        category: 'JavaScript',
        title: 'setTimeout 和 setInterval，你们两位同学注意点时间~ ',
        intro: '你们两位同学注意点时间~',
        imgsrc: require('../assets/image/ArticleImg2.webp'),
        content:
        '## 一、基本定义与用法 \n### 1、定义\n-   `setTimeout()`方法用于在指定的时间（单位毫秒）后执行回调函数或指定的一段代码\n-   `setInterval()`方法可按照指定的时间间隔（单位毫秒）来调用回调函数或指定的一段代码\n### 2、参数\n-   第一个参数 function，必填，回调函数。或者是一段字符串代码，但是这种方式不建议使用，就和使用`eval()`一样，有安全风险；而且还有作用域问题（字符串会在全局作用域内被解释执行）\n```\nsetTimeout(\'console.log(123);fn()\', 2000)\n```\n-   第二个参数 delay，可选，单位是 ms，对于`setTimeout`是延迟时间，对于`setInterval`是间隔时间，默认都是 0\n-   第三个参数 param1,param2,param3...，可选，是传递给回调函数的参数，不大常用\n ```\nsetTimeout(function (a, b) {\nconsole.log(a, b)\n}, 2000, \'我是\', \'定时器\')\n```\n### 3、返回值\n-   返回一个 ID（数字），可以将这个 ID 传递给`clearTimeout()`或`clearInterval()`来取消执行\n-   PS: `setTimeout()`和`setInterval()`共用一个编号池，技术上，`clearTimeout()`和`clearInterval()`可以互换使用，但是为了避免混淆，一般不这么做\n## 二、setTimeout 和 setInterval 的实际表现\n### 1、使用 setInterval 实现计时\n```\nconst startTime = new Date().getTime()\nlet count = 0\nconst interval = setInterval(function () {\ncount++\nconsole.log(new Date().getTime() - (startTime + count * 1000) + \'ms\')\nif(count === 10){\nclearInterval(interval);\n}\n}, 1000)\n```\n`new Date().getTime() - (startTime + count * 1000)`理想情况下应该是 0ms，然而事实并不是这样，而是存在着误差：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba8397cf6a184ed6a32b285693cff3c0~tplv-k3u1fbpfcp-zoom-1.image)\n### 2、使用 setTimeout 实现计时\n```\nconst startTime = new Date().getTime(), delay = 1000\nlet count = 0\nlet timer = setTimeout(doFunc, delay)\nfunction doFunc(){\ncount++\nconsole.log(new Date().getTime() - (startTime + count * 1000) + \'ms\')\nif(count < 10){\ntimer = setTimeout(doFunc, delay)\n}\n}\n```\nsetTimeout 也同样存在着误差，而且时间越来越大（setTimeout 需要在同步代码执行完成后才重新开始计时）：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c59850b3ac2a475eb718b5492630d88e~tplv-k3u1fbpfcp-zoom-1.image)\n## 三、为什么会出现误差\n### 1、setTimeout 的最短延迟时间\n`setTimeout`遵循的规范由 whatwg 来维护，在 [HTML Standard - 8.6 Timers](https://link.juejin.cn?target=https%3A%2F%2Fhtml.spec.whatwg.org%2Fmultipage%2Ftimers-and-user-prompts.html%23dom-settimeout "https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-settimeout") 中写到了定义定时器的详细步骤，其中有两条：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ffbfbab446fe494fb44c54181f48aa31~tplv-k3u1fbpfcp-zoom-1.image)\n上面的意思就是说，如果设置的 timeout 小于 0，则设置为 0，如果嵌套的层级超过了 5 层（计时器嵌套），并且 timeout 小于 4ms，则设置 timeout 为 4ms。并且，在不同浏览器中出现这种最小延迟的情况有所不同\n具体的源代码实现以及各大浏览器实现的不同，大家可以参考这篇文章：[为什么 setTimeout 有最小延时 4ms ？](https://link.juejin.cn?target=https%3A%2F%2Fwww.bruceyj.com%2Ffront-end-interview-summary%2Fsystem-design%2Fwhy-is-the-design%2F2-why-setTimeout-4ms.html "https://www.bruceyj.com/front-end-interview-summary/system-design/why-is-the-design/2-why-setTimeout-4ms.html")\n这里只看结论，定时器本身的定义步骤是造成其出现误差的原因之一\n### 2、setInterval 的最小间隔时间以及回调函数阻塞\n在 HTML5 标准中，setInterval 的最小间隔为 10ms，虽然我在规范文档中并未找到其相关说明，但是经过实际测试，也确实存在最小间隔时间，例如以下代码：\n```\nlet startTime = new Date().getTime()\nlet count = 0\nconst interval = setInterval(function () {\ncount++\n console.log(new Date().getTime() - startTime + \'ms\')\nstartTime = new Date().getTime()\nif(count === 10) {\nclearInterval(interval)\n}\n}, 0)\n```\n测试结果：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9bcffa807d384a7ab542fd1174186b12~tplv-k3u1fbpfcp-zoom-1.image)\n虽然没有 10ms 那么大的间隔，但是间隔仍然存在，猜测具体的间隔时间是和浏览器实现以及设备性能有关，无论如何，间隔是确实存在的\n另外，当使用 setInterval 时间间隔到点后，仅当队列中没有该定时器的任何其他代码实例时，才会将定时器的代码添加到队列中，如果有的话，则不会添加，造成堵塞，这个也与 JS 的事件循环有关\n### 3、未被激活的tabs的定时最小延迟 >= 1000ms\n为了优化后台 tab 的加载损耗（以及降低耗电量），在未被激活的 tab 中定时器的最小延时限制为1s(1000ms)，具体时间在不同的浏览器实现中也有差别\n### 4、JS 的事件循环机制\n`setTimeout`和`setInterval`中的时间并不是到点就立即执行，而是到点将其回调函数加入异步事件队列中，按照队列先进先出的性质，该回调函数到点之后是否能执行还得取决于是否属于队列首位，如果前头还有其他事件在等待，则不能按点执行，如果没有，则将其放入同步队列执行。具体事件循环机制，可以参考这篇文章：[动图学习-EventLoop](https://juejin.cn/post/6969028296893792286 "https://juejin.cn/post/6969028296893792286")\n## 四、解决方案\n### 1、在浏览器中实现一个 0ms 延时的定时器\n可以参考如下代码（来自于国外的一篇博客，也是 MDN 推荐的方法），主要是使用了 postMessage 方法，异步的执行了回调函数，并且速度要比 setTimeout(0) 要快的多。具体比较可以参照原文：[setTimeout with a shorter delay](https://link.juejin.cn?target=https%3A%2F%2Fdbaron.org%2Flog%2F20100309-faster-timeouts "https://dbaron.org/log/20100309-faster-timeouts")\n使用 setTimeout(0) 得到的时间：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8994a7da32e549cd9d06c34d1ac0bbc8~tplv-k3u1fbpfcp-zoom-1.image)\n将 setTimeout 改成 setZeroTimeout 后得到的时间，时间几乎都在 0～1，至于为什么不是绝对的 0，猜测可能与性能有关，总的来说，时间确实缩短了：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dced5471b7fc422d9f9eb28259b26ce2~tplv-k3u1fbpfcp-zoom-1.image)\n### 2、购物网站的秒杀活动\n一般情况下，从服务器拿到倒数时间后，前端的执行倒计时程序持续运行，事实上，显示时间相比实际时间会越来越慢的\n究其原因，倒计时通常是使用定时器实现，而 JS 的单线程特性使得同步任务执行过程中出现阻塞时，任务队列中的异步任务并不能及时执行，因此浏览器并不能保证在定时器设置的时间结束后代码总是被准时执行，从而造成了倒计时的偏差\n一般的解决方法是前端定时向服务器发送请求获取最新的时间差来校准倒计时时间，和用户一直按 F5 刷新没啥区别，比较简单粗暴，下面的方法可以一定程度上解决这个问题，纯前端控制，不依赖于后端。源地址已忘\n## 五、使用 setTimeout 替代 setInterval\n定时器指定的时间间隔，表示的是何时将定时器的代码添加到消息队列，而不是何时执行代码。所以真正何时执行代码的时间是不能保证的，它取决于何时被主线程的事件循环获取到，并执行\n假设有 `setInterval(function, 100)`，它的执行可能是这样的：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/30346ef998214cabb6c95141b19ad25f~tplv-k3u1fbpfcp-zoom-1.image)\n上图可见，setInterval 每隔 100ms 往队列中添加一个事件；100ms 后，添加 T1 定时器代码至队列中，主线程中还有任务在执行，所以等待，some event 执行结束后执行 T1 定时器代码；又过了100ms，T2定时器被添加到队列中，主线程还在执行 T1 代码，所以等待；又过了 100ms，理论上又要往队列里推一个定时器代码，但由于此时 T2 还在队列中，所以 T3 不会被添加，结果就是此时被跳过；然后，T1 定时器执行结束后马上执行了 T2 代码，所以并没有达到定时器间隔的效果\n综上所述，serInterval 有两个问题：\n-   可能多个定时器会连续执行（会导致后续的间隔误差）\n-   某些间隔会被跳过（这么设计也可能是为了尽量避免第一个问题）\n因而一般会使用 setTimeout 模拟 setInterval，来规避掉上面的缺点\n```\nsetTimeout(function fn() {\n// do something\nsetTimeout(fn, delay)\n}, delay)\n```\n这样的话，在前一个定时器代码执行完成前，不会向队列中插入新的定时器（不会连续执行），而且保证了定时器间隔\n注：有些说法，可能对当队列中存在定时器实例时，是否会跳过添加实例，存在质疑；还有的说法是，在 Node 环境中会跳过，在浏览器环境中会累加；不过我这边实测，不管在 Node 还是在 web 中，当队列中存在定时器实例时，都会跳过添加的；当然也有可能是浏览器版本或内核不同，表现不同，没有细测；感兴趣的小伙伴可以使用一下代码实测下，看是会一次性输出，还是会间隔性输出\n**这边顺便一提，涉及到做动画的场景可能会使用定时器**\n-   由于定时器的种种误差问题，以及固定时间间隔不一定与屏幕刷新时间相同，可能会引起丢帧；而且定时器在后台仍会继续执行，也会造成资源的浪费\n-   一般情况下，还是推荐使用 requestAnimationFrame，RAF 重绘或回流（重排）的时间间隔是紧紧跟随浏览器的刷新频率的；并且在页面未激活时，该页面的屏幕刷新任务也会被暂停，当页面被激活时，任务会从上次停留的地方继续执行，这也就意味着将耗费更少的资源，提升了性能\n### 总结\n-   setTimeout 和 setInterval 都存在计时误差，不会严格按照既定时间执行\n-   一般情况下，这些误差不会造成太大影响，只对于某些特殊场景，对时间要求比较严格的情况下，需要特殊处理\n-   对于 setInterval，个人建议能不用尽量不用，使用 setTimeout 的嵌套实现，可以规避掉一些潜在问题的发生\n'
      },{
        id: 10,
        name: 'ZEROL',
        day: '22',
        category: 'JavaScript',
        title: 'setTimeout 和 setInterval，你们两位同学注意点时间~ ',
        intro: '你们两位同学注意点时间~',
        imgsrc: require('../assets/image/ArticleImg2.webp'),
        content:
        '## 一、基本定义与用法 \n### 1、定义\n-   `setTimeout()`方法用于在指定的时间（单位毫秒）后执行回调函数或指定的一段代码\n-   `setInterval()`方法可按照指定的时间间隔（单位毫秒）来调用回调函数或指定的一段代码\n### 2、参数\n-   第一个参数 function，必填，回调函数。或者是一段字符串代码，但是这种方式不建议使用，就和使用`eval()`一样，有安全风险；而且还有作用域问题（字符串会在全局作用域内被解释执行）\n```\nsetTimeout(\'console.log(123);fn()\', 2000)\n```\n-   第二个参数 delay，可选，单位是 ms，对于`setTimeout`是延迟时间，对于`setInterval`是间隔时间，默认都是 0\n-   第三个参数 param1,param2,param3...，可选，是传递给回调函数的参数，不大常用\n ```\nsetTimeout(function (a, b) {\nconsole.log(a, b)\n}, 2000, \'我是\', \'定时器\')\n```\n### 3、返回值\n-   返回一个 ID（数字），可以将这个 ID 传递给`clearTimeout()`或`clearInterval()`来取消执行\n-   PS: `setTimeout()`和`setInterval()`共用一个编号池，技术上，`clearTimeout()`和`clearInterval()`可以互换使用，但是为了避免混淆，一般不这么做\n## 二、setTimeout 和 setInterval 的实际表现\n### 1、使用 setInterval 实现计时\n```\nconst startTime = new Date().getTime()\nlet count = 0\nconst interval = setInterval(function () {\ncount++\nconsole.log(new Date().getTime() - (startTime + count * 1000) + \'ms\')\nif(count === 10){\nclearInterval(interval);\n}\n}, 1000)\n```\n`new Date().getTime() - (startTime + count * 1000)`理想情况下应该是 0ms，然而事实并不是这样，而是存在着误差：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba8397cf6a184ed6a32b285693cff3c0~tplv-k3u1fbpfcp-zoom-1.image)\n### 2、使用 setTimeout 实现计时\n```\nconst startTime = new Date().getTime(), delay = 1000\nlet count = 0\nlet timer = setTimeout(doFunc, delay)\nfunction doFunc(){\ncount++\nconsole.log(new Date().getTime() - (startTime + count * 1000) + \'ms\')\nif(count < 10){\ntimer = setTimeout(doFunc, delay)\n}\n}\n```\nsetTimeout 也同样存在着误差，而且时间越来越大（setTimeout 需要在同步代码执行完成后才重新开始计时）：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c59850b3ac2a475eb718b5492630d88e~tplv-k3u1fbpfcp-zoom-1.image)\n## 三、为什么会出现误差\n### 1、setTimeout 的最短延迟时间\n`setTimeout`遵循的规范由 whatwg 来维护，在 [HTML Standard - 8.6 Timers](https://link.juejin.cn?target=https%3A%2F%2Fhtml.spec.whatwg.org%2Fmultipage%2Ftimers-and-user-prompts.html%23dom-settimeout "https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-settimeout") 中写到了定义定时器的详细步骤，其中有两条：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ffbfbab446fe494fb44c54181f48aa31~tplv-k3u1fbpfcp-zoom-1.image)\n上面的意思就是说，如果设置的 timeout 小于 0，则设置为 0，如果嵌套的层级超过了 5 层（计时器嵌套），并且 timeout 小于 4ms，则设置 timeout 为 4ms。并且，在不同浏览器中出现这种最小延迟的情况有所不同\n具体的源代码实现以及各大浏览器实现的不同，大家可以参考这篇文章：[为什么 setTimeout 有最小延时 4ms ？](https://link.juejin.cn?target=https%3A%2F%2Fwww.bruceyj.com%2Ffront-end-interview-summary%2Fsystem-design%2Fwhy-is-the-design%2F2-why-setTimeout-4ms.html "https://www.bruceyj.com/front-end-interview-summary/system-design/why-is-the-design/2-why-setTimeout-4ms.html")\n这里只看结论，定时器本身的定义步骤是造成其出现误差的原因之一\n### 2、setInterval 的最小间隔时间以及回调函数阻塞\n在 HTML5 标准中，setInterval 的最小间隔为 10ms，虽然我在规范文档中并未找到其相关说明，但是经过实际测试，也确实存在最小间隔时间，例如以下代码：\n```\nlet startTime = new Date().getTime()\nlet count = 0\nconst interval = setInterval(function () {\ncount++\n console.log(new Date().getTime() - startTime + \'ms\')\nstartTime = new Date().getTime()\nif(count === 10) {\nclearInterval(interval)\n}\n}, 0)\n```\n测试结果：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9bcffa807d384a7ab542fd1174186b12~tplv-k3u1fbpfcp-zoom-1.image)\n虽然没有 10ms 那么大的间隔，但是间隔仍然存在，猜测具体的间隔时间是和浏览器实现以及设备性能有关，无论如何，间隔是确实存在的\n另外，当使用 setInterval 时间间隔到点后，仅当队列中没有该定时器的任何其他代码实例时，才会将定时器的代码添加到队列中，如果有的话，则不会添加，造成堵塞，这个也与 JS 的事件循环有关\n### 3、未被激活的tabs的定时最小延迟 >= 1000ms\n为了优化后台 tab 的加载损耗（以及降低耗电量），在未被激活的 tab 中定时器的最小延时限制为1s(1000ms)，具体时间在不同的浏览器实现中也有差别\n### 4、JS 的事件循环机制\n`setTimeout`和`setInterval`中的时间并不是到点就立即执行，而是到点将其回调函数加入异步事件队列中，按照队列先进先出的性质，该回调函数到点之后是否能执行还得取决于是否属于队列首位，如果前头还有其他事件在等待，则不能按点执行，如果没有，则将其放入同步队列执行。具体事件循环机制，可以参考这篇文章：[动图学习-EventLoop](https://juejin.cn/post/6969028296893792286 "https://juejin.cn/post/6969028296893792286")\n## 四、解决方案\n### 1、在浏览器中实现一个 0ms 延时的定时器\n可以参考如下代码（来自于国外的一篇博客，也是 MDN 推荐的方法），主要是使用了 postMessage 方法，异步的执行了回调函数，并且速度要比 setTimeout(0) 要快的多。具体比较可以参照原文：[setTimeout with a shorter delay](https://link.juejin.cn?target=https%3A%2F%2Fdbaron.org%2Flog%2F20100309-faster-timeouts "https://dbaron.org/log/20100309-faster-timeouts")\n使用 setTimeout(0) 得到的时间：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8994a7da32e549cd9d06c34d1ac0bbc8~tplv-k3u1fbpfcp-zoom-1.image)\n将 setTimeout 改成 setZeroTimeout 后得到的时间，时间几乎都在 0～1，至于为什么不是绝对的 0，猜测可能与性能有关，总的来说，时间确实缩短了：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dced5471b7fc422d9f9eb28259b26ce2~tplv-k3u1fbpfcp-zoom-1.image)\n### 2、购物网站的秒杀活动\n一般情况下，从服务器拿到倒数时间后，前端的执行倒计时程序持续运行，事实上，显示时间相比实际时间会越来越慢的\n究其原因，倒计时通常是使用定时器实现，而 JS 的单线程特性使得同步任务执行过程中出现阻塞时，任务队列中的异步任务并不能及时执行，因此浏览器并不能保证在定时器设置的时间结束后代码总是被准时执行，从而造成了倒计时的偏差\n一般的解决方法是前端定时向服务器发送请求获取最新的时间差来校准倒计时时间，和用户一直按 F5 刷新没啥区别，比较简单粗暴，下面的方法可以一定程度上解决这个问题，纯前端控制，不依赖于后端。源地址已忘\n## 五、使用 setTimeout 替代 setInterval\n定时器指定的时间间隔，表示的是何时将定时器的代码添加到消息队列，而不是何时执行代码。所以真正何时执行代码的时间是不能保证的，它取决于何时被主线程的事件循环获取到，并执行\n假设有 `setInterval(function, 100)`，它的执行可能是这样的：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/30346ef998214cabb6c95141b19ad25f~tplv-k3u1fbpfcp-zoom-1.image)\n上图可见，setInterval 每隔 100ms 往队列中添加一个事件；100ms 后，添加 T1 定时器代码至队列中，主线程中还有任务在执行，所以等待，some event 执行结束后执行 T1 定时器代码；又过了100ms，T2定时器被添加到队列中，主线程还在执行 T1 代码，所以等待；又过了 100ms，理论上又要往队列里推一个定时器代码，但由于此时 T2 还在队列中，所以 T3 不会被添加，结果就是此时被跳过；然后，T1 定时器执行结束后马上执行了 T2 代码，所以并没有达到定时器间隔的效果\n综上所述，serInterval 有两个问题：\n-   可能多个定时器会连续执行（会导致后续的间隔误差）\n-   某些间隔会被跳过（这么设计也可能是为了尽量避免第一个问题）\n因而一般会使用 setTimeout 模拟 setInterval，来规避掉上面的缺点\n```\nsetTimeout(function fn() {\n// do something\nsetTimeout(fn, delay)\n}, delay)\n```\n这样的话，在前一个定时器代码执行完成前，不会向队列中插入新的定时器（不会连续执行），而且保证了定时器间隔\n注：有些说法，可能对当队列中存在定时器实例时，是否会跳过添加实例，存在质疑；还有的说法是，在 Node 环境中会跳过，在浏览器环境中会累加；不过我这边实测，不管在 Node 还是在 web 中，当队列中存在定时器实例时，都会跳过添加的；当然也有可能是浏览器版本或内核不同，表现不同，没有细测；感兴趣的小伙伴可以使用一下代码实测下，看是会一次性输出，还是会间隔性输出\n**这边顺便一提，涉及到做动画的场景可能会使用定时器**\n-   由于定时器的种种误差问题，以及固定时间间隔不一定与屏幕刷新时间相同，可能会引起丢帧；而且定时器在后台仍会继续执行，也会造成资源的浪费\n-   一般情况下，还是推荐使用 requestAnimationFrame，RAF 重绘或回流（重排）的时间间隔是紧紧跟随浏览器的刷新频率的；并且在页面未激活时，该页面的屏幕刷新任务也会被暂停，当页面被激活时，任务会从上次停留的地方继续执行，这也就意味着将耗费更少的资源，提升了性能\n### 总结\n-   setTimeout 和 setInterval 都存在计时误差，不会严格按照既定时间执行\n-   一般情况下，这些误差不会造成太大影响，只对于某些特殊场景，对时间要求比较严格的情况下，需要特殊处理\n-   对于 setInterval，个人建议能不用尽量不用，使用 setTimeout 的嵌套实现，可以规避掉一些潜在问题的发生\n'
      },{
        id: 11,
        name: '望舟',
        day: '1',
        category: '面试',
        title: '让“作用域和闭包”说人话！ ',
        intro: '让作用域和闭包说人话，面试时候有话可讲！',
        imgsrc: require('../assets/image/ArticleImg1.webp'),
        content:
        '# 一、作用域是什么\n作用域与编译原理息息相关，但是我们暂时还不用管编译原理的复杂过程，它的作用可以简单看下面这张图： \n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2dc72d14948848159ed01ab7af90a090~tplv-k3u1fbpfcp-zoom-1.image)\n简单来说就是“我得知道这些变量在哪里，不然我怎么取到它们再进行下一步操作呀！”\n***\nJavaScript的编译发生代码执行前的几微妙内，并不是发生在构建之前。\n引擎根据作用域进行变量查询，存在两种影响结果的查找方式——LHS/RHS。\nRHS（谁是源头【获取变量的值】）：需要找到这个变量的值才可以进行下一步操作。如console.log(a)，即得到a的值后执行操作。查询操作失败报ReferenceError异常，不合理操作报TypeError异常。\nLHS（目标是谁【对变量赋值】）：为操作找到一个容器，如var a = 2，即找到一个a，给它赋值为2。查询操作失败在非严格模式下会创建变量。*这个特性可以解释变量提升这个东西，也就是“赋值可以跑到声明前”。为了完成赋值这个动作，我可以自己声明一下嘛。现在可以暂时放一下这句话，等到提升时再想。*\n> ~~不推荐使用with/eval~~\n# 二、函数作用域和块作用域\n> 函数作用域含义：属于这个函数的全部变量都可以在整个函数的范围内使用或复用。\nfunction 开头的就是函数声明，其余则是函数表达式。 **正常函数声明被绑定在作用域中，函数表达式则绑定在函数自身中。** 这句话不理解可以先埋下一个伏笔，等下面看到闭包的时候再回头看会回味无穷。\n```\n// 函数声明\nfunction foo(){\nvar a = 2;\nconsole.log(a);\n}\nfoo()\n// 函数表达式\n(function foo(){\nvar a = 2;\nconsole.log(a);\n})()\nvar a = 2;\n(function IIFE(global){\nvar a = 3;\nconsole.log(a, global.a)// 3,2\n})(window)\n// 函数表达式\nvar foo = function(){\nconsole.log(1)\n}\n```\n那么怎么搞出一个块作用域呢？块作用域的声明方式有：\n1.  with 仅在with声明中有效\n1.  try/catch catch内的变量仅在catch内使用\n1.  let 劫持所在块的作用域\n1.  const 与let类似，变量不可修改\n块作用域的优势：1. 有利于垃圾回收（块作用域内代码执行后可以直接回收）；2. 解决 var 循环问题。\n# 三、提升\n> 没有赋值只有声明的变量是会报错 undefined，提升也只是提升了个声明而已；再换句话说，赋值可以跑在声明的前面。光说不干假把式~\n第一段代码可以顺利执行，因为对于 a 的声明会提升到最顶部，因此在作用域内能够找到a。但是这第二段代码中，`var a = 2;`会被拆分为两步，第一步是声明 a ，然后就执行了输出语句，还没有进行赋值呢，因此会出现报错。 这个例子恰好说明了“赋值可以跑在声明前面”。\n***\n例二：\n```\nfoo()\nfunction foo(){\nconsole.log(a); //undefined\nvar a;\n}\n```\n这里也是和例一一样，a会提升声明（作用域在foo内），但是只有声明，没有赋值，所以仍然会报错。\n***\n同样是声明提升，***函数的优先级高于变量***。这里的例子我们可以把函数表达式当作是一个变量的声明，相当于给foo2 这个变量赋值了一个函数。那么由于函数的优先级更高，这个foo2无法覆盖之前的foo1，所以输出仍然是1。\n# 四、闭包\n## 1. 闭包是什么\n首先我们得知道闭包是什么，来看看书里是怎么说的：\n> 函数在 定义时的词法作用域以外的地方 被调用，闭包使得函数可以继续访问定义时的词法作用域。\n这句话的形容使闭包看起来像一种_访问作用域的方法_。我们继续看下一句：\n> 无论通过何种手段将内部函数传递到所在的词法作用域以外，它都会持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包。\n**因此，不应该把比较理解成一种现象或者原理，应该作为一种工具方便我们使用来解决 JavaScript 中的一些问题。这是一个重要的理解点。** 用自己的话再来说一下闭包是什么吧：\n一个函数（A）引用着另一个函数的变量（B），即使 B 已经顺利执行结束了也不会被回收，因为 A 还引用着呢，所以 B 的各种变量也要被保存。\n'
      },{
        id:12,
        name: '望舟',
        day: '1',
        category: '面试',
        title: '让“作用域和闭包”说人话！ ',
        intro: '让作用域和闭包说人话，面试时候有话可讲！',
        imgsrc: require('../assets/image/ArticleImg1.webp'),
        content:
        '# 一、作用域是什么\n作用域与编译原理息息相关，但是我们暂时还不用管编译原理的复杂过程，它的作用可以简单看下面这张图： \n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2dc72d14948848159ed01ab7af90a090~tplv-k3u1fbpfcp-zoom-1.image)\n简单来说就是“我得知道这些变量在哪里，不然我怎么取到它们再进行下一步操作呀！”\n***\nJavaScript的编译发生代码执行前的几微妙内，并不是发生在构建之前。\n引擎根据作用域进行变量查询，存在两种影响结果的查找方式——LHS/RHS。\nRHS（谁是源头【获取变量的值】）：需要找到这个变量的值才可以进行下一步操作。如console.log(a)，即得到a的值后执行操作。查询操作失败报ReferenceError异常，不合理操作报TypeError异常。\nLHS（目标是谁【对变量赋值】）：为操作找到一个容器，如var a = 2，即找到一个a，给它赋值为2。查询操作失败在非严格模式下会创建变量。*这个特性可以解释变量提升这个东西，也就是“赋值可以跑到声明前”。为了完成赋值这个动作，我可以自己声明一下嘛。现在可以暂时放一下这句话，等到提升时再想。*\n> ~~不推荐使用with/eval~~\n# 二、函数作用域和块作用域\n> 函数作用域含义：属于这个函数的全部变量都可以在整个函数的范围内使用或复用。\nfunction 开头的就是函数声明，其余则是函数表达式。 **正常函数声明被绑定在作用域中，函数表达式则绑定在函数自身中。** 这句话不理解可以先埋下一个伏笔，等下面看到闭包的时候再回头看会回味无穷。\n```\n// 函数声明\nfunction foo(){\nvar a = 2;\nconsole.log(a);\n}\nfoo()\n// 函数表达式\n(function foo(){\nvar a = 2;\nconsole.log(a);\n})()\nvar a = 2;\n(function IIFE(global){\nvar a = 3;\nconsole.log(a, global.a)// 3,2\n})(window)\n// 函数表达式\nvar foo = function(){\nconsole.log(1)\n}\n```\n那么怎么搞出一个块作用域呢？块作用域的声明方式有：\n1.  with 仅在with声明中有效\n1.  try/catch catch内的变量仅在catch内使用\n1.  let 劫持所在块的作用域\n1.  const 与let类似，变量不可修改\n块作用域的优势：1. 有利于垃圾回收（块作用域内代码执行后可以直接回收）；2. 解决 var 循环问题。\n# 三、提升\n> 没有赋值只有声明的变量是会报错 undefined，提升也只是提升了个声明而已；再换句话说，赋值可以跑在声明的前面。光说不干假把式~\n第一段代码可以顺利执行，因为对于 a 的声明会提升到最顶部，因此在作用域内能够找到a。但是这第二段代码中，`var a = 2;`会被拆分为两步，第一步是声明 a ，然后就执行了输出语句，还没有进行赋值呢，因此会出现报错。 这个例子恰好说明了“赋值可以跑在声明前面”。\n***\n例二：\n```\nfoo()\nfunction foo(){\nconsole.log(a); //undefined\nvar a;\n}\n```\n这里也是和例一一样，a会提升声明（作用域在foo内），但是只有声明，没有赋值，所以仍然会报错。\n***\n同样是声明提升，***函数的优先级高于变量***。这里的例子我们可以把函数表达式当作是一个变量的声明，相当于给foo2 这个变量赋值了一个函数。那么由于函数的优先级更高，这个foo2无法覆盖之前的foo1，所以输出仍然是1。\n# 四、闭包\n## 1. 闭包是什么\n首先我们得知道闭包是什么，来看看书里是怎么说的：\n> 函数在 定义时的词法作用域以外的地方 被调用，闭包使得函数可以继续访问定义时的词法作用域。\n这句话的形容使闭包看起来像一种_访问作用域的方法_。我们继续看下一句：\n> 无论通过何种手段将内部函数传递到所在的词法作用域以外，它都会持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包。\n**因此，不应该把比较理解成一种现象或者原理，应该作为一种工具方便我们使用来解决 JavaScript 中的一些问题。这是一个重要的理解点。** 用自己的话再来说一下闭包是什么吧：\n一个函数（A）引用着另一个函数的变量（B），即使 B 已经顺利执行结束了也不会被回收，因为 A 还引用着呢，所以 B 的各种变量也要被保存。\n'
      },{
        id: 13,
        name: 'ZEROL',
        day: '22',
        category: 'JavaScript',
        title: 'setTimeout 和 setInterval，你们两位同学注意点时间~ ',
        intro: '你们两位同学注意点时间~',
        imgsrc: require('../assets/image/ArticleImg2.webp'),
        content:
        '## 一、基本定义与用法 \n### 1、定义\n-   `setTimeout()`方法用于在指定的时间（单位毫秒）后执行回调函数或指定的一段代码\n-   `setInterval()`方法可按照指定的时间间隔（单位毫秒）来调用回调函数或指定的一段代码\n### 2、参数\n-   第一个参数 function，必填，回调函数。或者是一段字符串代码，但是这种方式不建议使用，就和使用`eval()`一样，有安全风险；而且还有作用域问题（字符串会在全局作用域内被解释执行）\n```\nsetTimeout(\'console.log(123);fn()\', 2000)\n```\n-   第二个参数 delay，可选，单位是 ms，对于`setTimeout`是延迟时间，对于`setInterval`是间隔时间，默认都是 0\n-   第三个参数 param1,param2,param3...，可选，是传递给回调函数的参数，不大常用\n ```\nsetTimeout(function (a, b) {\nconsole.log(a, b)\n}, 2000, \'我是\', \'定时器\')\n```\n### 3、返回值\n-   返回一个 ID（数字），可以将这个 ID 传递给`clearTimeout()`或`clearInterval()`来取消执行\n-   PS: `setTimeout()`和`setInterval()`共用一个编号池，技术上，`clearTimeout()`和`clearInterval()`可以互换使用，但是为了避免混淆，一般不这么做\n## 二、setTimeout 和 setInterval 的实际表现\n### 1、使用 setInterval 实现计时\n```\nconst startTime = new Date().getTime()\nlet count = 0\nconst interval = setInterval(function () {\ncount++\nconsole.log(new Date().getTime() - (startTime + count * 1000) + \'ms\')\nif(count === 10){\nclearInterval(interval);\n}\n}, 1000)\n```\n`new Date().getTime() - (startTime + count * 1000)`理想情况下应该是 0ms，然而事实并不是这样，而是存在着误差：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba8397cf6a184ed6a32b285693cff3c0~tplv-k3u1fbpfcp-zoom-1.image)\n### 2、使用 setTimeout 实现计时\n```\nconst startTime = new Date().getTime(), delay = 1000\nlet count = 0\nlet timer = setTimeout(doFunc, delay)\nfunction doFunc(){\ncount++\nconsole.log(new Date().getTime() - (startTime + count * 1000) + \'ms\')\nif(count < 10){\ntimer = setTimeout(doFunc, delay)\n}\n}\n```\nsetTimeout 也同样存在着误差，而且时间越来越大（setTimeout 需要在同步代码执行完成后才重新开始计时）：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c59850b3ac2a475eb718b5492630d88e~tplv-k3u1fbpfcp-zoom-1.image)\n## 三、为什么会出现误差\n### 1、setTimeout 的最短延迟时间\n`setTimeout`遵循的规范由 whatwg 来维护，在 [HTML Standard - 8.6 Timers](https://link.juejin.cn?target=https%3A%2F%2Fhtml.spec.whatwg.org%2Fmultipage%2Ftimers-and-user-prompts.html%23dom-settimeout "https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-settimeout") 中写到了定义定时器的详细步骤，其中有两条：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ffbfbab446fe494fb44c54181f48aa31~tplv-k3u1fbpfcp-zoom-1.image)\n上面的意思就是说，如果设置的 timeout 小于 0，则设置为 0，如果嵌套的层级超过了 5 层（计时器嵌套），并且 timeout 小于 4ms，则设置 timeout 为 4ms。并且，在不同浏览器中出现这种最小延迟的情况有所不同\n具体的源代码实现以及各大浏览器实现的不同，大家可以参考这篇文章：[为什么 setTimeout 有最小延时 4ms ？](https://link.juejin.cn?target=https%3A%2F%2Fwww.bruceyj.com%2Ffront-end-interview-summary%2Fsystem-design%2Fwhy-is-the-design%2F2-why-setTimeout-4ms.html "https://www.bruceyj.com/front-end-interview-summary/system-design/why-is-the-design/2-why-setTimeout-4ms.html")\n这里只看结论，定时器本身的定义步骤是造成其出现误差的原因之一\n### 2、setInterval 的最小间隔时间以及回调函数阻塞\n在 HTML5 标准中，setInterval 的最小间隔为 10ms，虽然我在规范文档中并未找到其相关说明，但是经过实际测试，也确实存在最小间隔时间，例如以下代码：\n```\nlet startTime = new Date().getTime()\nlet count = 0\nconst interval = setInterval(function () {\ncount++\n console.log(new Date().getTime() - startTime + \'ms\')\nstartTime = new Date().getTime()\nif(count === 10) {\nclearInterval(interval)\n}\n}, 0)\n```\n测试结果：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9bcffa807d384a7ab542fd1174186b12~tplv-k3u1fbpfcp-zoom-1.image)\n虽然没有 10ms 那么大的间隔，但是间隔仍然存在，猜测具体的间隔时间是和浏览器实现以及设备性能有关，无论如何，间隔是确实存在的\n另外，当使用 setInterval 时间间隔到点后，仅当队列中没有该定时器的任何其他代码实例时，才会将定时器的代码添加到队列中，如果有的话，则不会添加，造成堵塞，这个也与 JS 的事件循环有关\n### 3、未被激活的tabs的定时最小延迟 >= 1000ms\n为了优化后台 tab 的加载损耗（以及降低耗电量），在未被激活的 tab 中定时器的最小延时限制为1s(1000ms)，具体时间在不同的浏览器实现中也有差别\n### 4、JS 的事件循环机制\n`setTimeout`和`setInterval`中的时间并不是到点就立即执行，而是到点将其回调函数加入异步事件队列中，按照队列先进先出的性质，该回调函数到点之后是否能执行还得取决于是否属于队列首位，如果前头还有其他事件在等待，则不能按点执行，如果没有，则将其放入同步队列执行。具体事件循环机制，可以参考这篇文章：[动图学习-EventLoop](https://juejin.cn/post/6969028296893792286 "https://juejin.cn/post/6969028296893792286")\n## 四、解决方案\n### 1、在浏览器中实现一个 0ms 延时的定时器\n可以参考如下代码（来自于国外的一篇博客，也是 MDN 推荐的方法），主要是使用了 postMessage 方法，异步的执行了回调函数，并且速度要比 setTimeout(0) 要快的多。具体比较可以参照原文：[setTimeout with a shorter delay](https://link.juejin.cn?target=https%3A%2F%2Fdbaron.org%2Flog%2F20100309-faster-timeouts "https://dbaron.org/log/20100309-faster-timeouts")\n使用 setTimeout(0) 得到的时间：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8994a7da32e549cd9d06c34d1ac0bbc8~tplv-k3u1fbpfcp-zoom-1.image)\n将 setTimeout 改成 setZeroTimeout 后得到的时间，时间几乎都在 0～1，至于为什么不是绝对的 0，猜测可能与性能有关，总的来说，时间确实缩短了：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dced5471b7fc422d9f9eb28259b26ce2~tplv-k3u1fbpfcp-zoom-1.image)\n### 2、购物网站的秒杀活动\n一般情况下，从服务器拿到倒数时间后，前端的执行倒计时程序持续运行，事实上，显示时间相比实际时间会越来越慢的\n究其原因，倒计时通常是使用定时器实现，而 JS 的单线程特性使得同步任务执行过程中出现阻塞时，任务队列中的异步任务并不能及时执行，因此浏览器并不能保证在定时器设置的时间结束后代码总是被准时执行，从而造成了倒计时的偏差\n一般的解决方法是前端定时向服务器发送请求获取最新的时间差来校准倒计时时间，和用户一直按 F5 刷新没啥区别，比较简单粗暴，下面的方法可以一定程度上解决这个问题，纯前端控制，不依赖于后端。源地址已忘\n## 五、使用 setTimeout 替代 setInterval\n定时器指定的时间间隔，表示的是何时将定时器的代码添加到消息队列，而不是何时执行代码。所以真正何时执行代码的时间是不能保证的，它取决于何时被主线程的事件循环获取到，并执行\n假设有 `setInterval(function, 100)`，它的执行可能是这样的：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/30346ef998214cabb6c95141b19ad25f~tplv-k3u1fbpfcp-zoom-1.image)\n上图可见，setInterval 每隔 100ms 往队列中添加一个事件；100ms 后，添加 T1 定时器代码至队列中，主线程中还有任务在执行，所以等待，some event 执行结束后执行 T1 定时器代码；又过了100ms，T2定时器被添加到队列中，主线程还在执行 T1 代码，所以等待；又过了 100ms，理论上又要往队列里推一个定时器代码，但由于此时 T2 还在队列中，所以 T3 不会被添加，结果就是此时被跳过；然后，T1 定时器执行结束后马上执行了 T2 代码，所以并没有达到定时器间隔的效果\n综上所述，serInterval 有两个问题：\n-   可能多个定时器会连续执行（会导致后续的间隔误差）\n-   某些间隔会被跳过（这么设计也可能是为了尽量避免第一个问题）\n因而一般会使用 setTimeout 模拟 setInterval，来规避掉上面的缺点\n```\nsetTimeout(function fn() {\n// do something\nsetTimeout(fn, delay)\n}, delay)\n```\n这样的话，在前一个定时器代码执行完成前，不会向队列中插入新的定时器（不会连续执行），而且保证了定时器间隔\n注：有些说法，可能对当队列中存在定时器实例时，是否会跳过添加实例，存在质疑；还有的说法是，在 Node 环境中会跳过，在浏览器环境中会累加；不过我这边实测，不管在 Node 还是在 web 中，当队列中存在定时器实例时，都会跳过添加的；当然也有可能是浏览器版本或内核不同，表现不同，没有细测；感兴趣的小伙伴可以使用一下代码实测下，看是会一次性输出，还是会间隔性输出\n**这边顺便一提，涉及到做动画的场景可能会使用定时器**\n-   由于定时器的种种误差问题，以及固定时间间隔不一定与屏幕刷新时间相同，可能会引起丢帧；而且定时器在后台仍会继续执行，也会造成资源的浪费\n-   一般情况下，还是推荐使用 requestAnimationFrame，RAF 重绘或回流（重排）的时间间隔是紧紧跟随浏览器的刷新频率的；并且在页面未激活时，该页面的屏幕刷新任务也会被暂停，当页面被激活时，任务会从上次停留的地方继续执行，这也就意味着将耗费更少的资源，提升了性能\n### 总结\n-   setTimeout 和 setInterval 都存在计时误差，不会严格按照既定时间执行\n-   一般情况下，这些误差不会造成太大影响，只对于某些特殊场景，对时间要求比较严格的情况下，需要特殊处理\n-   对于 setInterval，个人建议能不用尽量不用，使用 setTimeout 的嵌套实现，可以规避掉一些潜在问题的发生\n'
      },{
        id: 14,
        name: '望舟',
        day: '1',
        category: '面试',
        title: '让“作用域和闭包”说人话！ ',
        intro: '让作用域和闭包说人话，面试时候有话可讲！',
        imgsrc: require('../assets/image/ArticleImg1.webp'),
        content:
        '# 一、作用域是什么\n作用域与编译原理息息相关，但是我们暂时还不用管编译原理的复杂过程，它的作用可以简单看下面这张图： \n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2dc72d14948848159ed01ab7af90a090~tplv-k3u1fbpfcp-zoom-1.image)\n简单来说就是“我得知道这些变量在哪里，不然我怎么取到它们再进行下一步操作呀！”\n***\nJavaScript的编译发生代码执行前的几微妙内，并不是发生在构建之前。\n引擎根据作用域进行变量查询，存在两种影响结果的查找方式——LHS/RHS。\nRHS（谁是源头【获取变量的值】）：需要找到这个变量的值才可以进行下一步操作。如console.log(a)，即得到a的值后执行操作。查询操作失败报ReferenceError异常，不合理操作报TypeError异常。\nLHS（目标是谁【对变量赋值】）：为操作找到一个容器，如var a = 2，即找到一个a，给它赋值为2。查询操作失败在非严格模式下会创建变量。*这个特性可以解释变量提升这个东西，也就是“赋值可以跑到声明前”。为了完成赋值这个动作，我可以自己声明一下嘛。现在可以暂时放一下这句话，等到提升时再想。*\n> ~~不推荐使用with/eval~~\n# 二、函数作用域和块作用域\n> 函数作用域含义：属于这个函数的全部变量都可以在整个函数的范围内使用或复用。\nfunction 开头的就是函数声明，其余则是函数表达式。 **正常函数声明被绑定在作用域中，函数表达式则绑定在函数自身中。** 这句话不理解可以先埋下一个伏笔，等下面看到闭包的时候再回头看会回味无穷。\n```\n// 函数声明\nfunction foo(){\nvar a = 2;\nconsole.log(a);\n}\nfoo()\n// 函数表达式\n(function foo(){\nvar a = 2;\nconsole.log(a);\n})()\nvar a = 2;\n(function IIFE(global){\nvar a = 3;\nconsole.log(a, global.a)// 3,2\n})(window)\n// 函数表达式\nvar foo = function(){\nconsole.log(1)\n}\n```\n那么怎么搞出一个块作用域呢？块作用域的声明方式有：\n1.  with 仅在with声明中有效\n1.  try/catch catch内的变量仅在catch内使用\n1.  let 劫持所在块的作用域\n1.  const 与let类似，变量不可修改\n块作用域的优势：1. 有利于垃圾回收（块作用域内代码执行后可以直接回收）；2. 解决 var 循环问题。\n# 三、提升\n> 没有赋值只有声明的变量是会报错 undefined，提升也只是提升了个声明而已；再换句话说，赋值可以跑在声明的前面。光说不干假把式~\n第一段代码可以顺利执行，因为对于 a 的声明会提升到最顶部，因此在作用域内能够找到a。但是这第二段代码中，`var a = 2;`会被拆分为两步，第一步是声明 a ，然后就执行了输出语句，还没有进行赋值呢，因此会出现报错。 这个例子恰好说明了“赋值可以跑在声明前面”。\n***\n例二：\n```\nfoo()\nfunction foo(){\nconsole.log(a); //undefined\nvar a;\n}\n```\n这里也是和例一一样，a会提升声明（作用域在foo内），但是只有声明，没有赋值，所以仍然会报错。\n***\n同样是声明提升，***函数的优先级高于变量***。这里的例子我们可以把函数表达式当作是一个变量的声明，相当于给foo2 这个变量赋值了一个函数。那么由于函数的优先级更高，这个foo2无法覆盖之前的foo1，所以输出仍然是1。\n# 四、闭包\n## 1. 闭包是什么\n首先我们得知道闭包是什么，来看看书里是怎么说的：\n> 函数在 定义时的词法作用域以外的地方 被调用，闭包使得函数可以继续访问定义时的词法作用域。\n这句话的形容使闭包看起来像一种_访问作用域的方法_。我们继续看下一句：\n> 无论通过何种手段将内部函数传递到所在的词法作用域以外，它都会持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包。\n**因此，不应该把比较理解成一种现象或者原理，应该作为一种工具方便我们使用来解决 JavaScript 中的一些问题。这是一个重要的理解点。** 用自己的话再来说一下闭包是什么吧：\n一个函数（A）引用着另一个函数的变量（B），即使 B 已经顺利执行结束了也不会被回收，因为 A 还引用着呢，所以 B 的各种变量也要被保存。\n'
      },{
        id: 15,
        name: 'ZEROL',
        day: '22',
        category: 'JavaScript',
        title: 'setTimeout 和 setInterval，你们两位同学注意点时间~ ',
        intro: '你们两位同学注意点时间~',
        imgsrc: require('../assets/image/ArticleImg2.webp'),
        content:
        '## 一、基本定义与用法 \n### 1、定义\n-   `setTimeout()`方法用于在指定的时间（单位毫秒）后执行回调函数或指定的一段代码\n-   `setInterval()`方法可按照指定的时间间隔（单位毫秒）来调用回调函数或指定的一段代码\n### 2、参数\n-   第一个参数 function，必填，回调函数。或者是一段字符串代码，但是这种方式不建议使用，就和使用`eval()`一样，有安全风险；而且还有作用域问题（字符串会在全局作用域内被解释执行）\n```\nsetTimeout(\'console.log(123);fn()\', 2000)\n```\n-   第二个参数 delay，可选，单位是 ms，对于`setTimeout`是延迟时间，对于`setInterval`是间隔时间，默认都是 0\n-   第三个参数 param1,param2,param3...，可选，是传递给回调函数的参数，不大常用\n ```\nsetTimeout(function (a, b) {\nconsole.log(a, b)\n}, 2000, \'我是\', \'定时器\')\n```\n### 3、返回值\n-   返回一个 ID（数字），可以将这个 ID 传递给`clearTimeout()`或`clearInterval()`来取消执行\n-   PS: `setTimeout()`和`setInterval()`共用一个编号池，技术上，`clearTimeout()`和`clearInterval()`可以互换使用，但是为了避免混淆，一般不这么做\n## 二、setTimeout 和 setInterval 的实际表现\n### 1、使用 setInterval 实现计时\n```\nconst startTime = new Date().getTime()\nlet count = 0\nconst interval = setInterval(function () {\ncount++\nconsole.log(new Date().getTime() - (startTime + count * 1000) + \'ms\')\nif(count === 10){\nclearInterval(interval);\n}\n}, 1000)\n```\n`new Date().getTime() - (startTime + count * 1000)`理想情况下应该是 0ms，然而事实并不是这样，而是存在着误差：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba8397cf6a184ed6a32b285693cff3c0~tplv-k3u1fbpfcp-zoom-1.image)\n### 2、使用 setTimeout 实现计时\n```\nconst startTime = new Date().getTime(), delay = 1000\nlet count = 0\nlet timer = setTimeout(doFunc, delay)\nfunction doFunc(){\ncount++\nconsole.log(new Date().getTime() - (startTime + count * 1000) + \'ms\')\nif(count < 10){\ntimer = setTimeout(doFunc, delay)\n}\n}\n```\nsetTimeout 也同样存在着误差，而且时间越来越大（setTimeout 需要在同步代码执行完成后才重新开始计时）：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c59850b3ac2a475eb718b5492630d88e~tplv-k3u1fbpfcp-zoom-1.image)\n## 三、为什么会出现误差\n### 1、setTimeout 的最短延迟时间\n`setTimeout`遵循的规范由 whatwg 来维护，在 [HTML Standard - 8.6 Timers](https://link.juejin.cn?target=https%3A%2F%2Fhtml.spec.whatwg.org%2Fmultipage%2Ftimers-and-user-prompts.html%23dom-settimeout "https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-settimeout") 中写到了定义定时器的详细步骤，其中有两条：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ffbfbab446fe494fb44c54181f48aa31~tplv-k3u1fbpfcp-zoom-1.image)\n上面的意思就是说，如果设置的 timeout 小于 0，则设置为 0，如果嵌套的层级超过了 5 层（计时器嵌套），并且 timeout 小于 4ms，则设置 timeout 为 4ms。并且，在不同浏览器中出现这种最小延迟的情况有所不同\n具体的源代码实现以及各大浏览器实现的不同，大家可以参考这篇文章：[为什么 setTimeout 有最小延时 4ms ？](https://link.juejin.cn?target=https%3A%2F%2Fwww.bruceyj.com%2Ffront-end-interview-summary%2Fsystem-design%2Fwhy-is-the-design%2F2-why-setTimeout-4ms.html "https://www.bruceyj.com/front-end-interview-summary/system-design/why-is-the-design/2-why-setTimeout-4ms.html")\n这里只看结论，定时器本身的定义步骤是造成其出现误差的原因之一\n### 2、setInterval 的最小间隔时间以及回调函数阻塞\n在 HTML5 标准中，setInterval 的最小间隔为 10ms，虽然我在规范文档中并未找到其相关说明，但是经过实际测试，也确实存在最小间隔时间，例如以下代码：\n```\nlet startTime = new Date().getTime()\nlet count = 0\nconst interval = setInterval(function () {\ncount++\n console.log(new Date().getTime() - startTime + \'ms\')\nstartTime = new Date().getTime()\nif(count === 10) {\nclearInterval(interval)\n}\n}, 0)\n```\n测试结果：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9bcffa807d384a7ab542fd1174186b12~tplv-k3u1fbpfcp-zoom-1.image)\n虽然没有 10ms 那么大的间隔，但是间隔仍然存在，猜测具体的间隔时间是和浏览器实现以及设备性能有关，无论如何，间隔是确实存在的\n另外，当使用 setInterval 时间间隔到点后，仅当队列中没有该定时器的任何其他代码实例时，才会将定时器的代码添加到队列中，如果有的话，则不会添加，造成堵塞，这个也与 JS 的事件循环有关\n### 3、未被激活的tabs的定时最小延迟 >= 1000ms\n为了优化后台 tab 的加载损耗（以及降低耗电量），在未被激活的 tab 中定时器的最小延时限制为1s(1000ms)，具体时间在不同的浏览器实现中也有差别\n### 4、JS 的事件循环机制\n`setTimeout`和`setInterval`中的时间并不是到点就立即执行，而是到点将其回调函数加入异步事件队列中，按照队列先进先出的性质，该回调函数到点之后是否能执行还得取决于是否属于队列首位，如果前头还有其他事件在等待，则不能按点执行，如果没有，则将其放入同步队列执行。具体事件循环机制，可以参考这篇文章：[动图学习-EventLoop](https://juejin.cn/post/6969028296893792286 "https://juejin.cn/post/6969028296893792286")\n## 四、解决方案\n### 1、在浏览器中实现一个 0ms 延时的定时器\n可以参考如下代码（来自于国外的一篇博客，也是 MDN 推荐的方法），主要是使用了 postMessage 方法，异步的执行了回调函数，并且速度要比 setTimeout(0) 要快的多。具体比较可以参照原文：[setTimeout with a shorter delay](https://link.juejin.cn?target=https%3A%2F%2Fdbaron.org%2Flog%2F20100309-faster-timeouts "https://dbaron.org/log/20100309-faster-timeouts")\n使用 setTimeout(0) 得到的时间：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8994a7da32e549cd9d06c34d1ac0bbc8~tplv-k3u1fbpfcp-zoom-1.image)\n将 setTimeout 改成 setZeroTimeout 后得到的时间，时间几乎都在 0～1，至于为什么不是绝对的 0，猜测可能与性能有关，总的来说，时间确实缩短了：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dced5471b7fc422d9f9eb28259b26ce2~tplv-k3u1fbpfcp-zoom-1.image)\n### 2、购物网站的秒杀活动\n一般情况下，从服务器拿到倒数时间后，前端的执行倒计时程序持续运行，事实上，显示时间相比实际时间会越来越慢的\n究其原因，倒计时通常是使用定时器实现，而 JS 的单线程特性使得同步任务执行过程中出现阻塞时，任务队列中的异步任务并不能及时执行，因此浏览器并不能保证在定时器设置的时间结束后代码总是被准时执行，从而造成了倒计时的偏差\n一般的解决方法是前端定时向服务器发送请求获取最新的时间差来校准倒计时时间，和用户一直按 F5 刷新没啥区别，比较简单粗暴，下面的方法可以一定程度上解决这个问题，纯前端控制，不依赖于后端。源地址已忘\n## 五、使用 setTimeout 替代 setInterval\n定时器指定的时间间隔，表示的是何时将定时器的代码添加到消息队列，而不是何时执行代码。所以真正何时执行代码的时间是不能保证的，它取决于何时被主线程的事件循环获取到，并执行\n假设有 `setInterval(function, 100)`，它的执行可能是这样的：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/30346ef998214cabb6c95141b19ad25f~tplv-k3u1fbpfcp-zoom-1.image)\n上图可见，setInterval 每隔 100ms 往队列中添加一个事件；100ms 后，添加 T1 定时器代码至队列中，主线程中还有任务在执行，所以等待，some event 执行结束后执行 T1 定时器代码；又过了100ms，T2定时器被添加到队列中，主线程还在执行 T1 代码，所以等待；又过了 100ms，理论上又要往队列里推一个定时器代码，但由于此时 T2 还在队列中，所以 T3 不会被添加，结果就是此时被跳过；然后，T1 定时器执行结束后马上执行了 T2 代码，所以并没有达到定时器间隔的效果\n综上所述，serInterval 有两个问题：\n-   可能多个定时器会连续执行（会导致后续的间隔误差）\n-   某些间隔会被跳过（这么设计也可能是为了尽量避免第一个问题）\n因而一般会使用 setTimeout 模拟 setInterval，来规避掉上面的缺点\n```\nsetTimeout(function fn() {\n// do something\nsetTimeout(fn, delay)\n}, delay)\n```\n这样的话，在前一个定时器代码执行完成前，不会向队列中插入新的定时器（不会连续执行），而且保证了定时器间隔\n注：有些说法，可能对当队列中存在定时器实例时，是否会跳过添加实例，存在质疑；还有的说法是，在 Node 环境中会跳过，在浏览器环境中会累加；不过我这边实测，不管在 Node 还是在 web 中，当队列中存在定时器实例时，都会跳过添加的；当然也有可能是浏览器版本或内核不同，表现不同，没有细测；感兴趣的小伙伴可以使用一下代码实测下，看是会一次性输出，还是会间隔性输出\n**这边顺便一提，涉及到做动画的场景可能会使用定时器**\n-   由于定时器的种种误差问题，以及固定时间间隔不一定与屏幕刷新时间相同，可能会引起丢帧；而且定时器在后台仍会继续执行，也会造成资源的浪费\n-   一般情况下，还是推荐使用 requestAnimationFrame，RAF 重绘或回流（重排）的时间间隔是紧紧跟随浏览器的刷新频率的；并且在页面未激活时，该页面的屏幕刷新任务也会被暂停，当页面被激活时，任务会从上次停留的地方继续执行，这也就意味着将耗费更少的资源，提升了性能\n### 总结\n-   setTimeout 和 setInterval 都存在计时误差，不会严格按照既定时间执行\n-   一般情况下，这些误差不会造成太大影响，只对于某些特殊场景，对时间要求比较严格的情况下，需要特殊处理\n-   对于 setInterval，个人建议能不用尽量不用，使用 setTimeout 的嵌套实现，可以规避掉一些潜在问题的发生\n'
      },{
        id: 16,
        name: 'ZEROL',
        day: '22',
        category: 'JavaScript',
        title: 'setTimeout 和 setInterval，你们两位同学注意点时间~ ',
        intro: '你们两位同学注意点时间~',
        imgsrc: require('../assets/image/ArticleImg2.webp'),
        content:
        '## 一、基本定义与用法 \n### 1、定义\n-   `setTimeout()`方法用于在指定的时间（单位毫秒）后执行回调函数或指定的一段代码\n-   `setInterval()`方法可按照指定的时间间隔（单位毫秒）来调用回调函数或指定的一段代码\n### 2、参数\n-   第一个参数 function，必填，回调函数。或者是一段字符串代码，但是这种方式不建议使用，就和使用`eval()`一样，有安全风险；而且还有作用域问题（字符串会在全局作用域内被解释执行）\n```\nsetTimeout(\'console.log(123);fn()\', 2000)\n```\n-   第二个参数 delay，可选，单位是 ms，对于`setTimeout`是延迟时间，对于`setInterval`是间隔时间，默认都是 0\n-   第三个参数 param1,param2,param3...，可选，是传递给回调函数的参数，不大常用\n ```\nsetTimeout(function (a, b) {\nconsole.log(a, b)\n}, 2000, \'我是\', \'定时器\')\n```\n### 3、返回值\n-   返回一个 ID（数字），可以将这个 ID 传递给`clearTimeout()`或`clearInterval()`来取消执行\n-   PS: `setTimeout()`和`setInterval()`共用一个编号池，技术上，`clearTimeout()`和`clearInterval()`可以互换使用，但是为了避免混淆，一般不这么做\n## 二、setTimeout 和 setInterval 的实际表现\n### 1、使用 setInterval 实现计时\n```\nconst startTime = new Date().getTime()\nlet count = 0\nconst interval = setInterval(function () {\ncount++\nconsole.log(new Date().getTime() - (startTime + count * 1000) + \'ms\')\nif(count === 10){\nclearInterval(interval);\n}\n}, 1000)\n```\n`new Date().getTime() - (startTime + count * 1000)`理想情况下应该是 0ms，然而事实并不是这样，而是存在着误差：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba8397cf6a184ed6a32b285693cff3c0~tplv-k3u1fbpfcp-zoom-1.image)\n### 2、使用 setTimeout 实现计时\n```\nconst startTime = new Date().getTime(), delay = 1000\nlet count = 0\nlet timer = setTimeout(doFunc, delay)\nfunction doFunc(){\ncount++\nconsole.log(new Date().getTime() - (startTime + count * 1000) + \'ms\')\nif(count < 10){\ntimer = setTimeout(doFunc, delay)\n}\n}\n```\nsetTimeout 也同样存在着误差，而且时间越来越大（setTimeout 需要在同步代码执行完成后才重新开始计时）：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c59850b3ac2a475eb718b5492630d88e~tplv-k3u1fbpfcp-zoom-1.image)\n## 三、为什么会出现误差\n### 1、setTimeout 的最短延迟时间\n`setTimeout`遵循的规范由 whatwg 来维护，在 [HTML Standard - 8.6 Timers](https://link.juejin.cn?target=https%3A%2F%2Fhtml.spec.whatwg.org%2Fmultipage%2Ftimers-and-user-prompts.html%23dom-settimeout "https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-settimeout") 中写到了定义定时器的详细步骤，其中有两条：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ffbfbab446fe494fb44c54181f48aa31~tplv-k3u1fbpfcp-zoom-1.image)\n上面的意思就是说，如果设置的 timeout 小于 0，则设置为 0，如果嵌套的层级超过了 5 层（计时器嵌套），并且 timeout 小于 4ms，则设置 timeout 为 4ms。并且，在不同浏览器中出现这种最小延迟的情况有所不同\n具体的源代码实现以及各大浏览器实现的不同，大家可以参考这篇文章：[为什么 setTimeout 有最小延时 4ms ？](https://link.juejin.cn?target=https%3A%2F%2Fwww.bruceyj.com%2Ffront-end-interview-summary%2Fsystem-design%2Fwhy-is-the-design%2F2-why-setTimeout-4ms.html "https://www.bruceyj.com/front-end-interview-summary/system-design/why-is-the-design/2-why-setTimeout-4ms.html")\n这里只看结论，定时器本身的定义步骤是造成其出现误差的原因之一\n### 2、setInterval 的最小间隔时间以及回调函数阻塞\n在 HTML5 标准中，setInterval 的最小间隔为 10ms，虽然我在规范文档中并未找到其相关说明，但是经过实际测试，也确实存在最小间隔时间，例如以下代码：\n```\nlet startTime = new Date().getTime()\nlet count = 0\nconst interval = setInterval(function () {\ncount++\n console.log(new Date().getTime() - startTime + \'ms\')\nstartTime = new Date().getTime()\nif(count === 10) {\nclearInterval(interval)\n}\n}, 0)\n```\n测试结果：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9bcffa807d384a7ab542fd1174186b12~tplv-k3u1fbpfcp-zoom-1.image)\n虽然没有 10ms 那么大的间隔，但是间隔仍然存在，猜测具体的间隔时间是和浏览器实现以及设备性能有关，无论如何，间隔是确实存在的\n另外，当使用 setInterval 时间间隔到点后，仅当队列中没有该定时器的任何其他代码实例时，才会将定时器的代码添加到队列中，如果有的话，则不会添加，造成堵塞，这个也与 JS 的事件循环有关\n### 3、未被激活的tabs的定时最小延迟 >= 1000ms\n为了优化后台 tab 的加载损耗（以及降低耗电量），在未被激活的 tab 中定时器的最小延时限制为1s(1000ms)，具体时间在不同的浏览器实现中也有差别\n### 4、JS 的事件循环机制\n`setTimeout`和`setInterval`中的时间并不是到点就立即执行，而是到点将其回调函数加入异步事件队列中，按照队列先进先出的性质，该回调函数到点之后是否能执行还得取决于是否属于队列首位，如果前头还有其他事件在等待，则不能按点执行，如果没有，则将其放入同步队列执行。具体事件循环机制，可以参考这篇文章：[动图学习-EventLoop](https://juejin.cn/post/6969028296893792286 "https://juejin.cn/post/6969028296893792286")\n## 四、解决方案\n### 1、在浏览器中实现一个 0ms 延时的定时器\n可以参考如下代码（来自于国外的一篇博客，也是 MDN 推荐的方法），主要是使用了 postMessage 方法，异步的执行了回调函数，并且速度要比 setTimeout(0) 要快的多。具体比较可以参照原文：[setTimeout with a shorter delay](https://link.juejin.cn?target=https%3A%2F%2Fdbaron.org%2Flog%2F20100309-faster-timeouts "https://dbaron.org/log/20100309-faster-timeouts")\n使用 setTimeout(0) 得到的时间：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8994a7da32e549cd9d06c34d1ac0bbc8~tplv-k3u1fbpfcp-zoom-1.image)\n将 setTimeout 改成 setZeroTimeout 后得到的时间，时间几乎都在 0～1，至于为什么不是绝对的 0，猜测可能与性能有关，总的来说，时间确实缩短了：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dced5471b7fc422d9f9eb28259b26ce2~tplv-k3u1fbpfcp-zoom-1.image)\n### 2、购物网站的秒杀活动\n一般情况下，从服务器拿到倒数时间后，前端的执行倒计时程序持续运行，事实上，显示时间相比实际时间会越来越慢的\n究其原因，倒计时通常是使用定时器实现，而 JS 的单线程特性使得同步任务执行过程中出现阻塞时，任务队列中的异步任务并不能及时执行，因此浏览器并不能保证在定时器设置的时间结束后代码总是被准时执行，从而造成了倒计时的偏差\n一般的解决方法是前端定时向服务器发送请求获取最新的时间差来校准倒计时时间，和用户一直按 F5 刷新没啥区别，比较简单粗暴，下面的方法可以一定程度上解决这个问题，纯前端控制，不依赖于后端。源地址已忘\n## 五、使用 setTimeout 替代 setInterval\n定时器指定的时间间隔，表示的是何时将定时器的代码添加到消息队列，而不是何时执行代码。所以真正何时执行代码的时间是不能保证的，它取决于何时被主线程的事件循环获取到，并执行\n假设有 `setInterval(function, 100)`，它的执行可能是这样的：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/30346ef998214cabb6c95141b19ad25f~tplv-k3u1fbpfcp-zoom-1.image)\n上图可见，setInterval 每隔 100ms 往队列中添加一个事件；100ms 后，添加 T1 定时器代码至队列中，主线程中还有任务在执行，所以等待，some event 执行结束后执行 T1 定时器代码；又过了100ms，T2定时器被添加到队列中，主线程还在执行 T1 代码，所以等待；又过了 100ms，理论上又要往队列里推一个定时器代码，但由于此时 T2 还在队列中，所以 T3 不会被添加，结果就是此时被跳过；然后，T1 定时器执行结束后马上执行了 T2 代码，所以并没有达到定时器间隔的效果\n综上所述，serInterval 有两个问题：\n-   可能多个定时器会连续执行（会导致后续的间隔误差）\n-   某些间隔会被跳过（这么设计也可能是为了尽量避免第一个问题）\n因而一般会使用 setTimeout 模拟 setInterval，来规避掉上面的缺点\n```\nsetTimeout(function fn() {\n// do something\nsetTimeout(fn, delay)\n}, delay)\n```\n这样的话，在前一个定时器代码执行完成前，不会向队列中插入新的定时器（不会连续执行），而且保证了定时器间隔\n注：有些说法，可能对当队列中存在定时器实例时，是否会跳过添加实例，存在质疑；还有的说法是，在 Node 环境中会跳过，在浏览器环境中会累加；不过我这边实测，不管在 Node 还是在 web 中，当队列中存在定时器实例时，都会跳过添加的；当然也有可能是浏览器版本或内核不同，表现不同，没有细测；感兴趣的小伙伴可以使用一下代码实测下，看是会一次性输出，还是会间隔性输出\n**这边顺便一提，涉及到做动画的场景可能会使用定时器**\n-   由于定时器的种种误差问题，以及固定时间间隔不一定与屏幕刷新时间相同，可能会引起丢帧；而且定时器在后台仍会继续执行，也会造成资源的浪费\n-   一般情况下，还是推荐使用 requestAnimationFrame，RAF 重绘或回流（重排）的时间间隔是紧紧跟随浏览器的刷新频率的；并且在页面未激活时，该页面的屏幕刷新任务也会被暂停，当页面被激活时，任务会从上次停留的地方继续执行，这也就意味着将耗费更少的资源，提升了性能\n### 总结\n-   setTimeout 和 setInterval 都存在计时误差，不会严格按照既定时间执行\n-   一般情况下，这些误差不会造成太大影响，只对于某些特殊场景，对时间要求比较严格的情况下，需要特殊处理\n-   对于 setInterval，个人建议能不用尽量不用，使用 setTimeout 的嵌套实现，可以规避掉一些潜在问题的发生\n'
      },{
        id: 17,
        name: 'ZEROL',
        day: '22',
        category: 'JavaScript',
        title: 'setTimeout 和 setInterval，你们两位同学注意点时间~ ',
        intro: '你们两位同学注意点时间~',
        imgsrc: require('../assets/image/ArticleImg2.webp'),
        content:
        '## 一、基本定义与用法 \n### 1、定义\n-   `setTimeout()`方法用于在指定的时间（单位毫秒）后执行回调函数或指定的一段代码\n-   `setInterval()`方法可按照指定的时间间隔（单位毫秒）来调用回调函数或指定的一段代码\n### 2、参数\n-   第一个参数 function，必填，回调函数。或者是一段字符串代码，但是这种方式不建议使用，就和使用`eval()`一样，有安全风险；而且还有作用域问题（字符串会在全局作用域内被解释执行）\n```\nsetTimeout(\'console.log(123);fn()\', 2000)\n```\n-   第二个参数 delay，可选，单位是 ms，对于`setTimeout`是延迟时间，对于`setInterval`是间隔时间，默认都是 0\n-   第三个参数 param1,param2,param3...，可选，是传递给回调函数的参数，不大常用\n ```\nsetTimeout(function (a, b) {\nconsole.log(a, b)\n}, 2000, \'我是\', \'定时器\')\n```\n### 3、返回值\n-   返回一个 ID（数字），可以将这个 ID 传递给`clearTimeout()`或`clearInterval()`来取消执行\n-   PS: `setTimeout()`和`setInterval()`共用一个编号池，技术上，`clearTimeout()`和`clearInterval()`可以互换使用，但是为了避免混淆，一般不这么做\n## 二、setTimeout 和 setInterval 的实际表现\n### 1、使用 setInterval 实现计时\n```\nconst startTime = new Date().getTime()\nlet count = 0\nconst interval = setInterval(function () {\ncount++\nconsole.log(new Date().getTime() - (startTime + count * 1000) + \'ms\')\nif(count === 10){\nclearInterval(interval);\n}\n}, 1000)\n```\n`new Date().getTime() - (startTime + count * 1000)`理想情况下应该是 0ms，然而事实并不是这样，而是存在着误差：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba8397cf6a184ed6a32b285693cff3c0~tplv-k3u1fbpfcp-zoom-1.image)\n### 2、使用 setTimeout 实现计时\n```\nconst startTime = new Date().getTime(), delay = 1000\nlet count = 0\nlet timer = setTimeout(doFunc, delay)\nfunction doFunc(){\ncount++\nconsole.log(new Date().getTime() - (startTime + count * 1000) + \'ms\')\nif(count < 10){\ntimer = setTimeout(doFunc, delay)\n}\n}\n```\nsetTimeout 也同样存在着误差，而且时间越来越大（setTimeout 需要在同步代码执行完成后才重新开始计时）：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c59850b3ac2a475eb718b5492630d88e~tplv-k3u1fbpfcp-zoom-1.image)\n## 三、为什么会出现误差\n### 1、setTimeout 的最短延迟时间\n`setTimeout`遵循的规范由 whatwg 来维护，在 [HTML Standard - 8.6 Timers](https://link.juejin.cn?target=https%3A%2F%2Fhtml.spec.whatwg.org%2Fmultipage%2Ftimers-and-user-prompts.html%23dom-settimeout "https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-settimeout") 中写到了定义定时器的详细步骤，其中有两条：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ffbfbab446fe494fb44c54181f48aa31~tplv-k3u1fbpfcp-zoom-1.image)\n上面的意思就是说，如果设置的 timeout 小于 0，则设置为 0，如果嵌套的层级超过了 5 层（计时器嵌套），并且 timeout 小于 4ms，则设置 timeout 为 4ms。并且，在不同浏览器中出现这种最小延迟的情况有所不同\n具体的源代码实现以及各大浏览器实现的不同，大家可以参考这篇文章：[为什么 setTimeout 有最小延时 4ms ？](https://link.juejin.cn?target=https%3A%2F%2Fwww.bruceyj.com%2Ffront-end-interview-summary%2Fsystem-design%2Fwhy-is-the-design%2F2-why-setTimeout-4ms.html "https://www.bruceyj.com/front-end-interview-summary/system-design/why-is-the-design/2-why-setTimeout-4ms.html")\n这里只看结论，定时器本身的定义步骤是造成其出现误差的原因之一\n### 2、setInterval 的最小间隔时间以及回调函数阻塞\n在 HTML5 标准中，setInterval 的最小间隔为 10ms，虽然我在规范文档中并未找到其相关说明，但是经过实际测试，也确实存在最小间隔时间，例如以下代码：\n```\nlet startTime = new Date().getTime()\nlet count = 0\nconst interval = setInterval(function () {\ncount++\n console.log(new Date().getTime() - startTime + \'ms\')\nstartTime = new Date().getTime()\nif(count === 10) {\nclearInterval(interval)\n}\n}, 0)\n```\n测试结果：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9bcffa807d384a7ab542fd1174186b12~tplv-k3u1fbpfcp-zoom-1.image)\n虽然没有 10ms 那么大的间隔，但是间隔仍然存在，猜测具体的间隔时间是和浏览器实现以及设备性能有关，无论如何，间隔是确实存在的\n另外，当使用 setInterval 时间间隔到点后，仅当队列中没有该定时器的任何其他代码实例时，才会将定时器的代码添加到队列中，如果有的话，则不会添加，造成堵塞，这个也与 JS 的事件循环有关\n### 3、未被激活的tabs的定时最小延迟 >= 1000ms\n为了优化后台 tab 的加载损耗（以及降低耗电量），在未被激活的 tab 中定时器的最小延时限制为1s(1000ms)，具体时间在不同的浏览器实现中也有差别\n### 4、JS 的事件循环机制\n`setTimeout`和`setInterval`中的时间并不是到点就立即执行，而是到点将其回调函数加入异步事件队列中，按照队列先进先出的性质，该回调函数到点之后是否能执行还得取决于是否属于队列首位，如果前头还有其他事件在等待，则不能按点执行，如果没有，则将其放入同步队列执行。具体事件循环机制，可以参考这篇文章：[动图学习-EventLoop](https://juejin.cn/post/6969028296893792286 "https://juejin.cn/post/6969028296893792286")\n## 四、解决方案\n### 1、在浏览器中实现一个 0ms 延时的定时器\n可以参考如下代码（来自于国外的一篇博客，也是 MDN 推荐的方法），主要是使用了 postMessage 方法，异步的执行了回调函数，并且速度要比 setTimeout(0) 要快的多。具体比较可以参照原文：[setTimeout with a shorter delay](https://link.juejin.cn?target=https%3A%2F%2Fdbaron.org%2Flog%2F20100309-faster-timeouts "https://dbaron.org/log/20100309-faster-timeouts")\n使用 setTimeout(0) 得到的时间：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8994a7da32e549cd9d06c34d1ac0bbc8~tplv-k3u1fbpfcp-zoom-1.image)\n将 setTimeout 改成 setZeroTimeout 后得到的时间，时间几乎都在 0～1，至于为什么不是绝对的 0，猜测可能与性能有关，总的来说，时间确实缩短了：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dced5471b7fc422d9f9eb28259b26ce2~tplv-k3u1fbpfcp-zoom-1.image)\n### 2、购物网站的秒杀活动\n一般情况下，从服务器拿到倒数时间后，前端的执行倒计时程序持续运行，事实上，显示时间相比实际时间会越来越慢的\n究其原因，倒计时通常是使用定时器实现，而 JS 的单线程特性使得同步任务执行过程中出现阻塞时，任务队列中的异步任务并不能及时执行，因此浏览器并不能保证在定时器设置的时间结束后代码总是被准时执行，从而造成了倒计时的偏差\n一般的解决方法是前端定时向服务器发送请求获取最新的时间差来校准倒计时时间，和用户一直按 F5 刷新没啥区别，比较简单粗暴，下面的方法可以一定程度上解决这个问题，纯前端控制，不依赖于后端。源地址已忘\n## 五、使用 setTimeout 替代 setInterval\n定时器指定的时间间隔，表示的是何时将定时器的代码添加到消息队列，而不是何时执行代码。所以真正何时执行代码的时间是不能保证的，它取决于何时被主线程的事件循环获取到，并执行\n假设有 `setInterval(function, 100)`，它的执行可能是这样的：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/30346ef998214cabb6c95141b19ad25f~tplv-k3u1fbpfcp-zoom-1.image)\n上图可见，setInterval 每隔 100ms 往队列中添加一个事件；100ms 后，添加 T1 定时器代码至队列中，主线程中还有任务在执行，所以等待，some event 执行结束后执行 T1 定时器代码；又过了100ms，T2定时器被添加到队列中，主线程还在执行 T1 代码，所以等待；又过了 100ms，理论上又要往队列里推一个定时器代码，但由于此时 T2 还在队列中，所以 T3 不会被添加，结果就是此时被跳过；然后，T1 定时器执行结束后马上执行了 T2 代码，所以并没有达到定时器间隔的效果\n综上所述，serInterval 有两个问题：\n-   可能多个定时器会连续执行（会导致后续的间隔误差）\n-   某些间隔会被跳过（这么设计也可能是为了尽量避免第一个问题）\n因而一般会使用 setTimeout 模拟 setInterval，来规避掉上面的缺点\n```\nsetTimeout(function fn() {\n// do something\nsetTimeout(fn, delay)\n}, delay)\n```\n这样的话，在前一个定时器代码执行完成前，不会向队列中插入新的定时器（不会连续执行），而且保证了定时器间隔\n注：有些说法，可能对当队列中存在定时器实例时，是否会跳过添加实例，存在质疑；还有的说法是，在 Node 环境中会跳过，在浏览器环境中会累加；不过我这边实测，不管在 Node 还是在 web 中，当队列中存在定时器实例时，都会跳过添加的；当然也有可能是浏览器版本或内核不同，表现不同，没有细测；感兴趣的小伙伴可以使用一下代码实测下，看是会一次性输出，还是会间隔性输出\n**这边顺便一提，涉及到做动画的场景可能会使用定时器**\n-   由于定时器的种种误差问题，以及固定时间间隔不一定与屏幕刷新时间相同，可能会引起丢帧；而且定时器在后台仍会继续执行，也会造成资源的浪费\n-   一般情况下，还是推荐使用 requestAnimationFrame，RAF 重绘或回流（重排）的时间间隔是紧紧跟随浏览器的刷新频率的；并且在页面未激活时，该页面的屏幕刷新任务也会被暂停，当页面被激活时，任务会从上次停留的地方继续执行，这也就意味着将耗费更少的资源，提升了性能\n### 总结\n-   setTimeout 和 setInterval 都存在计时误差，不会严格按照既定时间执行\n-   一般情况下，这些误差不会造成太大影响，只对于某些特殊场景，对时间要求比较严格的情况下，需要特殊处理\n-   对于 setInterval，个人建议能不用尽量不用，使用 setTimeout 的嵌套实现，可以规避掉一些潜在问题的发生\n'
      },{
        id: 18,
        name: '望舟',
        day: '1',
        category: '面试',
        title: '让“作用域和闭包”说人话！ ',
        intro: '让作用域和闭包说人话，面试时候有话可讲！',
        imgsrc: require('../assets/image/ArticleImg1.webp'),
        content:
        '# 一、作用域是什么\n作用域与编译原理息息相关，但是我们暂时还不用管编译原理的复杂过程，它的作用可以简单看下面这张图： \n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2dc72d14948848159ed01ab7af90a090~tplv-k3u1fbpfcp-zoom-1.image)\n简单来说就是“我得知道这些变量在哪里，不然我怎么取到它们再进行下一步操作呀！”\n***\nJavaScript的编译发生代码执行前的几微妙内，并不是发生在构建之前。\n引擎根据作用域进行变量查询，存在两种影响结果的查找方式——LHS/RHS。\nRHS（谁是源头【获取变量的值】）：需要找到这个变量的值才可以进行下一步操作。如console.log(a)，即得到a的值后执行操作。查询操作失败报ReferenceError异常，不合理操作报TypeError异常。\nLHS（目标是谁【对变量赋值】）：为操作找到一个容器，如var a = 2，即找到一个a，给它赋值为2。查询操作失败在非严格模式下会创建变量。*这个特性可以解释变量提升这个东西，也就是“赋值可以跑到声明前”。为了完成赋值这个动作，我可以自己声明一下嘛。现在可以暂时放一下这句话，等到提升时再想。*\n> ~~不推荐使用with/eval~~\n# 二、函数作用域和块作用域\n> 函数作用域含义：属于这个函数的全部变量都可以在整个函数的范围内使用或复用。\nfunction 开头的就是函数声明，其余则是函数表达式。 **正常函数声明被绑定在作用域中，函数表达式则绑定在函数自身中。** 这句话不理解可以先埋下一个伏笔，等下面看到闭包的时候再回头看会回味无穷。\n```\n// 函数声明\nfunction foo(){\nvar a = 2;\nconsole.log(a);\n}\nfoo()\n// 函数表达式\n(function foo(){\nvar a = 2;\nconsole.log(a);\n})()\nvar a = 2;\n(function IIFE(global){\nvar a = 3;\nconsole.log(a, global.a)// 3,2\n})(window)\n// 函数表达式\nvar foo = function(){\nconsole.log(1)\n}\n```\n那么怎么搞出一个块作用域呢？块作用域的声明方式有：\n1.  with 仅在with声明中有效\n1.  try/catch catch内的变量仅在catch内使用\n1.  let 劫持所在块的作用域\n1.  const 与let类似，变量不可修改\n块作用域的优势：1. 有利于垃圾回收（块作用域内代码执行后可以直接回收）；2. 解决 var 循环问题。\n# 三、提升\n> 没有赋值只有声明的变量是会报错 undefined，提升也只是提升了个声明而已；再换句话说，赋值可以跑在声明的前面。光说不干假把式~\n第一段代码可以顺利执行，因为对于 a 的声明会提升到最顶部，因此在作用域内能够找到a。但是这第二段代码中，`var a = 2;`会被拆分为两步，第一步是声明 a ，然后就执行了输出语句，还没有进行赋值呢，因此会出现报错。 这个例子恰好说明了“赋值可以跑在声明前面”。\n***\n例二：\n```\nfoo()\nfunction foo(){\nconsole.log(a); //undefined\nvar a;\n}\n```\n这里也是和例一一样，a会提升声明（作用域在foo内），但是只有声明，没有赋值，所以仍然会报错。\n***\n同样是声明提升，***函数的优先级高于变量***。这里的例子我们可以把函数表达式当作是一个变量的声明，相当于给foo2 这个变量赋值了一个函数。那么由于函数的优先级更高，这个foo2无法覆盖之前的foo1，所以输出仍然是1。\n# 四、闭包\n## 1. 闭包是什么\n首先我们得知道闭包是什么，来看看书里是怎么说的：\n> 函数在 定义时的词法作用域以外的地方 被调用，闭包使得函数可以继续访问定义时的词法作用域。\n这句话的形容使闭包看起来像一种_访问作用域的方法_。我们继续看下一句：\n> 无论通过何种手段将内部函数传递到所在的词法作用域以外，它都会持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包。\n**因此，不应该把比较理解成一种现象或者原理，应该作为一种工具方便我们使用来解决 JavaScript 中的一些问题。这是一个重要的理解点。** 用自己的话再来说一下闭包是什么吧：\n一个函数（A）引用着另一个函数的变量（B），即使 B 已经顺利执行结束了也不会被回收，因为 A 还引用着呢，所以 B 的各种变量也要被保存。\n'
      },{
        id: 19,
        name: 'ZEROL',
        day: '22',
        category: 'JavaScript',
        title: 'setTimeout 和 setInterval，你们两位同学注意点时间~ ',
        intro: '你们两位同学注意点时间~',
        imgsrc: require('../assets/image/ArticleImg2.webp'),
        content:
        '## 一、基本定义与用法 \n### 1、定义\n-   `setTimeout()`方法用于在指定的时间（单位毫秒）后执行回调函数或指定的一段代码\n-   `setInterval()`方法可按照指定的时间间隔（单位毫秒）来调用回调函数或指定的一段代码\n### 2、参数\n-   第一个参数 function，必填，回调函数。或者是一段字符串代码，但是这种方式不建议使用，就和使用`eval()`一样，有安全风险；而且还有作用域问题（字符串会在全局作用域内被解释执行）\n```\nsetTimeout(\'console.log(123);fn()\', 2000)\n```\n-   第二个参数 delay，可选，单位是 ms，对于`setTimeout`是延迟时间，对于`setInterval`是间隔时间，默认都是 0\n-   第三个参数 param1,param2,param3...，可选，是传递给回调函数的参数，不大常用\n ```\nsetTimeout(function (a, b) {\nconsole.log(a, b)\n}, 2000, \'我是\', \'定时器\')\n```\n### 3、返回值\n-   返回一个 ID（数字），可以将这个 ID 传递给`clearTimeout()`或`clearInterval()`来取消执行\n-   PS: `setTimeout()`和`setInterval()`共用一个编号池，技术上，`clearTimeout()`和`clearInterval()`可以互换使用，但是为了避免混淆，一般不这么做\n## 二、setTimeout 和 setInterval 的实际表现\n### 1、使用 setInterval 实现计时\n```\nconst startTime = new Date().getTime()\nlet count = 0\nconst interval = setInterval(function () {\ncount++\nconsole.log(new Date().getTime() - (startTime + count * 1000) + \'ms\')\nif(count === 10){\nclearInterval(interval);\n}\n}, 1000)\n```\n`new Date().getTime() - (startTime + count * 1000)`理想情况下应该是 0ms，然而事实并不是这样，而是存在着误差：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba8397cf6a184ed6a32b285693cff3c0~tplv-k3u1fbpfcp-zoom-1.image)\n### 2、使用 setTimeout 实现计时\n```\nconst startTime = new Date().getTime(), delay = 1000\nlet count = 0\nlet timer = setTimeout(doFunc, delay)\nfunction doFunc(){\ncount++\nconsole.log(new Date().getTime() - (startTime + count * 1000) + \'ms\')\nif(count < 10){\ntimer = setTimeout(doFunc, delay)\n}\n}\n```\nsetTimeout 也同样存在着误差，而且时间越来越大（setTimeout 需要在同步代码执行完成后才重新开始计时）：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c59850b3ac2a475eb718b5492630d88e~tplv-k3u1fbpfcp-zoom-1.image)\n## 三、为什么会出现误差\n### 1、setTimeout 的最短延迟时间\n`setTimeout`遵循的规范由 whatwg 来维护，在 [HTML Standard - 8.6 Timers](https://link.juejin.cn?target=https%3A%2F%2Fhtml.spec.whatwg.org%2Fmultipage%2Ftimers-and-user-prompts.html%23dom-settimeout "https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-settimeout") 中写到了定义定时器的详细步骤，其中有两条：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ffbfbab446fe494fb44c54181f48aa31~tplv-k3u1fbpfcp-zoom-1.image)\n上面的意思就是说，如果设置的 timeout 小于 0，则设置为 0，如果嵌套的层级超过了 5 层（计时器嵌套），并且 timeout 小于 4ms，则设置 timeout 为 4ms。并且，在不同浏览器中出现这种最小延迟的情况有所不同\n具体的源代码实现以及各大浏览器实现的不同，大家可以参考这篇文章：[为什么 setTimeout 有最小延时 4ms ？](https://link.juejin.cn?target=https%3A%2F%2Fwww.bruceyj.com%2Ffront-end-interview-summary%2Fsystem-design%2Fwhy-is-the-design%2F2-why-setTimeout-4ms.html "https://www.bruceyj.com/front-end-interview-summary/system-design/why-is-the-design/2-why-setTimeout-4ms.html")\n这里只看结论，定时器本身的定义步骤是造成其出现误差的原因之一\n### 2、setInterval 的最小间隔时间以及回调函数阻塞\n在 HTML5 标准中，setInterval 的最小间隔为 10ms，虽然我在规范文档中并未找到其相关说明，但是经过实际测试，也确实存在最小间隔时间，例如以下代码：\n```\nlet startTime = new Date().getTime()\nlet count = 0\nconst interval = setInterval(function () {\ncount++\n console.log(new Date().getTime() - startTime + \'ms\')\nstartTime = new Date().getTime()\nif(count === 10) {\nclearInterval(interval)\n}\n}, 0)\n```\n测试结果：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9bcffa807d384a7ab542fd1174186b12~tplv-k3u1fbpfcp-zoom-1.image)\n虽然没有 10ms 那么大的间隔，但是间隔仍然存在，猜测具体的间隔时间是和浏览器实现以及设备性能有关，无论如何，间隔是确实存在的\n另外，当使用 setInterval 时间间隔到点后，仅当队列中没有该定时器的任何其他代码实例时，才会将定时器的代码添加到队列中，如果有的话，则不会添加，造成堵塞，这个也与 JS 的事件循环有关\n### 3、未被激活的tabs的定时最小延迟 >= 1000ms\n为了优化后台 tab 的加载损耗（以及降低耗电量），在未被激活的 tab 中定时器的最小延时限制为1s(1000ms)，具体时间在不同的浏览器实现中也有差别\n### 4、JS 的事件循环机制\n`setTimeout`和`setInterval`中的时间并不是到点就立即执行，而是到点将其回调函数加入异步事件队列中，按照队列先进先出的性质，该回调函数到点之后是否能执行还得取决于是否属于队列首位，如果前头还有其他事件在等待，则不能按点执行，如果没有，则将其放入同步队列执行。具体事件循环机制，可以参考这篇文章：[动图学习-EventLoop](https://juejin.cn/post/6969028296893792286 "https://juejin.cn/post/6969028296893792286")\n## 四、解决方案\n### 1、在浏览器中实现一个 0ms 延时的定时器\n可以参考如下代码（来自于国外的一篇博客，也是 MDN 推荐的方法），主要是使用了 postMessage 方法，异步的执行了回调函数，并且速度要比 setTimeout(0) 要快的多。具体比较可以参照原文：[setTimeout with a shorter delay](https://link.juejin.cn?target=https%3A%2F%2Fdbaron.org%2Flog%2F20100309-faster-timeouts "https://dbaron.org/log/20100309-faster-timeouts")\n使用 setTimeout(0) 得到的时间：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8994a7da32e549cd9d06c34d1ac0bbc8~tplv-k3u1fbpfcp-zoom-1.image)\n将 setTimeout 改成 setZeroTimeout 后得到的时间，时间几乎都在 0～1，至于为什么不是绝对的 0，猜测可能与性能有关，总的来说，时间确实缩短了：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dced5471b7fc422d9f9eb28259b26ce2~tplv-k3u1fbpfcp-zoom-1.image)\n### 2、购物网站的秒杀活动\n一般情况下，从服务器拿到倒数时间后，前端的执行倒计时程序持续运行，事实上，显示时间相比实际时间会越来越慢的\n究其原因，倒计时通常是使用定时器实现，而 JS 的单线程特性使得同步任务执行过程中出现阻塞时，任务队列中的异步任务并不能及时执行，因此浏览器并不能保证在定时器设置的时间结束后代码总是被准时执行，从而造成了倒计时的偏差\n一般的解决方法是前端定时向服务器发送请求获取最新的时间差来校准倒计时时间，和用户一直按 F5 刷新没啥区别，比较简单粗暴，下面的方法可以一定程度上解决这个问题，纯前端控制，不依赖于后端。源地址已忘\n## 五、使用 setTimeout 替代 setInterval\n定时器指定的时间间隔，表示的是何时将定时器的代码添加到消息队列，而不是何时执行代码。所以真正何时执行代码的时间是不能保证的，它取决于何时被主线程的事件循环获取到，并执行\n假设有 `setInterval(function, 100)`，它的执行可能是这样的：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/30346ef998214cabb6c95141b19ad25f~tplv-k3u1fbpfcp-zoom-1.image)\n上图可见，setInterval 每隔 100ms 往队列中添加一个事件；100ms 后，添加 T1 定时器代码至队列中，主线程中还有任务在执行，所以等待，some event 执行结束后执行 T1 定时器代码；又过了100ms，T2定时器被添加到队列中，主线程还在执行 T1 代码，所以等待；又过了 100ms，理论上又要往队列里推一个定时器代码，但由于此时 T2 还在队列中，所以 T3 不会被添加，结果就是此时被跳过；然后，T1 定时器执行结束后马上执行了 T2 代码，所以并没有达到定时器间隔的效果\n综上所述，serInterval 有两个问题：\n-   可能多个定时器会连续执行（会导致后续的间隔误差）\n-   某些间隔会被跳过（这么设计也可能是为了尽量避免第一个问题）\n因而一般会使用 setTimeout 模拟 setInterval，来规避掉上面的缺点\n```\nsetTimeout(function fn() {\n// do something\nsetTimeout(fn, delay)\n}, delay)\n```\n这样的话，在前一个定时器代码执行完成前，不会向队列中插入新的定时器（不会连续执行），而且保证了定时器间隔\n注：有些说法，可能对当队列中存在定时器实例时，是否会跳过添加实例，存在质疑；还有的说法是，在 Node 环境中会跳过，在浏览器环境中会累加；不过我这边实测，不管在 Node 还是在 web 中，当队列中存在定时器实例时，都会跳过添加的；当然也有可能是浏览器版本或内核不同，表现不同，没有细测；感兴趣的小伙伴可以使用一下代码实测下，看是会一次性输出，还是会间隔性输出\n**这边顺便一提，涉及到做动画的场景可能会使用定时器**\n-   由于定时器的种种误差问题，以及固定时间间隔不一定与屏幕刷新时间相同，可能会引起丢帧；而且定时器在后台仍会继续执行，也会造成资源的浪费\n-   一般情况下，还是推荐使用 requestAnimationFrame，RAF 重绘或回流（重排）的时间间隔是紧紧跟随浏览器的刷新频率的；并且在页面未激活时，该页面的屏幕刷新任务也会被暂停，当页面被激活时，任务会从上次停留的地方继续执行，这也就意味着将耗费更少的资源，提升了性能\n### 总结\n-   setTimeout 和 setInterval 都存在计时误差，不会严格按照既定时间执行\n-   一般情况下，这些误差不会造成太大影响，只对于某些特殊场景，对时间要求比较严格的情况下，需要特殊处理\n-   对于 setInterval，个人建议能不用尽量不用，使用 setTimeout 的嵌套实现，可以规避掉一些潜在问题的发生\n'
      },{
        id: 20,
        name: '望舟',
        day: '1',
        category: '面试',
        title: '让“作用域和闭包”说人话！ ',
        intro: '让作用域和闭包说人话，面试时候有话可讲！',
        imgsrc: require('../assets/image/ArticleImg1.webp'),
        content:
        '# 一、作用域是什么\n作用域与编译原理息息相关，但是我们暂时还不用管编译原理的复杂过程，它的作用可以简单看下面这张图： \n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2dc72d14948848159ed01ab7af90a090~tplv-k3u1fbpfcp-zoom-1.image)\n简单来说就是“我得知道这些变量在哪里，不然我怎么取到它们再进行下一步操作呀！”\n***\nJavaScript的编译发生代码执行前的几微妙内，并不是发生在构建之前。\n引擎根据作用域进行变量查询，存在两种影响结果的查找方式——LHS/RHS。\nRHS（谁是源头【获取变量的值】）：需要找到这个变量的值才可以进行下一步操作。如console.log(a)，即得到a的值后执行操作。查询操作失败报ReferenceError异常，不合理操作报TypeError异常。\nLHS（目标是谁【对变量赋值】）：为操作找到一个容器，如var a = 2，即找到一个a，给它赋值为2。查询操作失败在非严格模式下会创建变量。*这个特性可以解释变量提升这个东西，也就是“赋值可以跑到声明前”。为了完成赋值这个动作，我可以自己声明一下嘛。现在可以暂时放一下这句话，等到提升时再想。*\n> ~~不推荐使用with/eval~~\n# 二、函数作用域和块作用域\n> 函数作用域含义：属于这个函数的全部变量都可以在整个函数的范围内使用或复用。\nfunction 开头的就是函数声明，其余则是函数表达式。 **正常函数声明被绑定在作用域中，函数表达式则绑定在函数自身中。** 这句话不理解可以先埋下一个伏笔，等下面看到闭包的时候再回头看会回味无穷。\n```\n// 函数声明\nfunction foo(){\nvar a = 2;\nconsole.log(a);\n}\nfoo()\n// 函数表达式\n(function foo(){\nvar a = 2;\nconsole.log(a);\n})()\nvar a = 2;\n(function IIFE(global){\nvar a = 3;\nconsole.log(a, global.a)// 3,2\n})(window)\n// 函数表达式\nvar foo = function(){\nconsole.log(1)\n}\n```\n那么怎么搞出一个块作用域呢？块作用域的声明方式有：\n1.  with 仅在with声明中有效\n1.  try/catch catch内的变量仅在catch内使用\n1.  let 劫持所在块的作用域\n1.  const 与let类似，变量不可修改\n块作用域的优势：1. 有利于垃圾回收（块作用域内代码执行后可以直接回收）；2. 解决 var 循环问题。\n# 三、提升\n> 没有赋值只有声明的变量是会报错 undefined，提升也只是提升了个声明而已；再换句话说，赋值可以跑在声明的前面。光说不干假把式~\n第一段代码可以顺利执行，因为对于 a 的声明会提升到最顶部，因此在作用域内能够找到a。但是这第二段代码中，`var a = 2;`会被拆分为两步，第一步是声明 a ，然后就执行了输出语句，还没有进行赋值呢，因此会出现报错。 这个例子恰好说明了“赋值可以跑在声明前面”。\n***\n例二：\n```\nfoo()\nfunction foo(){\nconsole.log(a); //undefined\nvar a;\n}\n```\n这里也是和例一一样，a会提升声明（作用域在foo内），但是只有声明，没有赋值，所以仍然会报错。\n***\n同样是声明提升，***函数的优先级高于变量***。这里的例子我们可以把函数表达式当作是一个变量的声明，相当于给foo2 这个变量赋值了一个函数。那么由于函数的优先级更高，这个foo2无法覆盖之前的foo1，所以输出仍然是1。\n# 四、闭包\n## 1. 闭包是什么\n首先我们得知道闭包是什么，来看看书里是怎么说的：\n> 函数在 定义时的词法作用域以外的地方 被调用，闭包使得函数可以继续访问定义时的词法作用域。\n这句话的形容使闭包看起来像一种_访问作用域的方法_。我们继续看下一句：\n> 无论通过何种手段将内部函数传递到所在的词法作用域以外，它都会持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包。\n**因此，不应该把比较理解成一种现象或者原理，应该作为一种工具方便我们使用来解决 JavaScript 中的一些问题。这是一个重要的理解点。** 用自己的话再来说一下闭包是什么吧：\n一个函数（A）引用着另一个函数的变量（B），即使 B 已经顺利执行结束了也不会被回收，因为 A 还引用着呢，所以 B 的各种变量也要被保存。\n'
      },{
        id: 21,
        name: 'ZEROL',
        day: '22',
        category: 'JavaScript',
        title: 'setTimeout 和 setInterval，你们两位同学注意点时间~ ',
        intro: '你们两位同学注意点时间~',
        imgsrc: require('../assets/image/ArticleImg2.webp'),
        content:
        '## 一、基本定义与用法 \n### 1、定义\n-   `setTimeout()`方法用于在指定的时间（单位毫秒）后执行回调函数或指定的一段代码\n-   `setInterval()`方法可按照指定的时间间隔（单位毫秒）来调用回调函数或指定的一段代码\n### 2、参数\n-   第一个参数 function，必填，回调函数。或者是一段字符串代码，但是这种方式不建议使用，就和使用`eval()`一样，有安全风险；而且还有作用域问题（字符串会在全局作用域内被解释执行）\n```\nsetTimeout(\'console.log(123);fn()\', 2000)\n```\n-   第二个参数 delay，可选，单位是 ms，对于`setTimeout`是延迟时间，对于`setInterval`是间隔时间，默认都是 0\n-   第三个参数 param1,param2,param3...，可选，是传递给回调函数的参数，不大常用\n ```\nsetTimeout(function (a, b) {\nconsole.log(a, b)\n}, 2000, \'我是\', \'定时器\')\n```\n### 3、返回值\n-   返回一个 ID（数字），可以将这个 ID 传递给`clearTimeout()`或`clearInterval()`来取消执行\n-   PS: `setTimeout()`和`setInterval()`共用一个编号池，技术上，`clearTimeout()`和`clearInterval()`可以互换使用，但是为了避免混淆，一般不这么做\n## 二、setTimeout 和 setInterval 的实际表现\n### 1、使用 setInterval 实现计时\n```\nconst startTime = new Date().getTime()\nlet count = 0\nconst interval = setInterval(function () {\ncount++\nconsole.log(new Date().getTime() - (startTime + count * 1000) + \'ms\')\nif(count === 10){\nclearInterval(interval);\n}\n}, 1000)\n```\n`new Date().getTime() - (startTime + count * 1000)`理想情况下应该是 0ms，然而事实并不是这样，而是存在着误差：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba8397cf6a184ed6a32b285693cff3c0~tplv-k3u1fbpfcp-zoom-1.image)\n### 2、使用 setTimeout 实现计时\n```\nconst startTime = new Date().getTime(), delay = 1000\nlet count = 0\nlet timer = setTimeout(doFunc, delay)\nfunction doFunc(){\ncount++\nconsole.log(new Date().getTime() - (startTime + count * 1000) + \'ms\')\nif(count < 10){\ntimer = setTimeout(doFunc, delay)\n}\n}\n```\nsetTimeout 也同样存在着误差，而且时间越来越大（setTimeout 需要在同步代码执行完成后才重新开始计时）：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c59850b3ac2a475eb718b5492630d88e~tplv-k3u1fbpfcp-zoom-1.image)\n## 三、为什么会出现误差\n### 1、setTimeout 的最短延迟时间\n`setTimeout`遵循的规范由 whatwg 来维护，在 [HTML Standard - 8.6 Timers](https://link.juejin.cn?target=https%3A%2F%2Fhtml.spec.whatwg.org%2Fmultipage%2Ftimers-and-user-prompts.html%23dom-settimeout "https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-settimeout") 中写到了定义定时器的详细步骤，其中有两条：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ffbfbab446fe494fb44c54181f48aa31~tplv-k3u1fbpfcp-zoom-1.image)\n上面的意思就是说，如果设置的 timeout 小于 0，则设置为 0，如果嵌套的层级超过了 5 层（计时器嵌套），并且 timeout 小于 4ms，则设置 timeout 为 4ms。并且，在不同浏览器中出现这种最小延迟的情况有所不同\n具体的源代码实现以及各大浏览器实现的不同，大家可以参考这篇文章：[为什么 setTimeout 有最小延时 4ms ？](https://link.juejin.cn?target=https%3A%2F%2Fwww.bruceyj.com%2Ffront-end-interview-summary%2Fsystem-design%2Fwhy-is-the-design%2F2-why-setTimeout-4ms.html "https://www.bruceyj.com/front-end-interview-summary/system-design/why-is-the-design/2-why-setTimeout-4ms.html")\n这里只看结论，定时器本身的定义步骤是造成其出现误差的原因之一\n### 2、setInterval 的最小间隔时间以及回调函数阻塞\n在 HTML5 标准中，setInterval 的最小间隔为 10ms，虽然我在规范文档中并未找到其相关说明，但是经过实际测试，也确实存在最小间隔时间，例如以下代码：\n```\nlet startTime = new Date().getTime()\nlet count = 0\nconst interval = setInterval(function () {\ncount++\n console.log(new Date().getTime() - startTime + \'ms\')\nstartTime = new Date().getTime()\nif(count === 10) {\nclearInterval(interval)\n}\n}, 0)\n```\n测试结果：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9bcffa807d384a7ab542fd1174186b12~tplv-k3u1fbpfcp-zoom-1.image)\n虽然没有 10ms 那么大的间隔，但是间隔仍然存在，猜测具体的间隔时间是和浏览器实现以及设备性能有关，无论如何，间隔是确实存在的\n另外，当使用 setInterval 时间间隔到点后，仅当队列中没有该定时器的任何其他代码实例时，才会将定时器的代码添加到队列中，如果有的话，则不会添加，造成堵塞，这个也与 JS 的事件循环有关\n### 3、未被激活的tabs的定时最小延迟 >= 1000ms\n为了优化后台 tab 的加载损耗（以及降低耗电量），在未被激活的 tab 中定时器的最小延时限制为1s(1000ms)，具体时间在不同的浏览器实现中也有差别\n### 4、JS 的事件循环机制\n`setTimeout`和`setInterval`中的时间并不是到点就立即执行，而是到点将其回调函数加入异步事件队列中，按照队列先进先出的性质，该回调函数到点之后是否能执行还得取决于是否属于队列首位，如果前头还有其他事件在等待，则不能按点执行，如果没有，则将其放入同步队列执行。具体事件循环机制，可以参考这篇文章：[动图学习-EventLoop](https://juejin.cn/post/6969028296893792286 "https://juejin.cn/post/6969028296893792286")\n## 四、解决方案\n### 1、在浏览器中实现一个 0ms 延时的定时器\n可以参考如下代码（来自于国外的一篇博客，也是 MDN 推荐的方法），主要是使用了 postMessage 方法，异步的执行了回调函数，并且速度要比 setTimeout(0) 要快的多。具体比较可以参照原文：[setTimeout with a shorter delay](https://link.juejin.cn?target=https%3A%2F%2Fdbaron.org%2Flog%2F20100309-faster-timeouts "https://dbaron.org/log/20100309-faster-timeouts")\n使用 setTimeout(0) 得到的时间：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8994a7da32e549cd9d06c34d1ac0bbc8~tplv-k3u1fbpfcp-zoom-1.image)\n将 setTimeout 改成 setZeroTimeout 后得到的时间，时间几乎都在 0～1，至于为什么不是绝对的 0，猜测可能与性能有关，总的来说，时间确实缩短了：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dced5471b7fc422d9f9eb28259b26ce2~tplv-k3u1fbpfcp-zoom-1.image)\n### 2、购物网站的秒杀活动\n一般情况下，从服务器拿到倒数时间后，前端的执行倒计时程序持续运行，事实上，显示时间相比实际时间会越来越慢的\n究其原因，倒计时通常是使用定时器实现，而 JS 的单线程特性使得同步任务执行过程中出现阻塞时，任务队列中的异步任务并不能及时执行，因此浏览器并不能保证在定时器设置的时间结束后代码总是被准时执行，从而造成了倒计时的偏差\n一般的解决方法是前端定时向服务器发送请求获取最新的时间差来校准倒计时时间，和用户一直按 F5 刷新没啥区别，比较简单粗暴，下面的方法可以一定程度上解决这个问题，纯前端控制，不依赖于后端。源地址已忘\n## 五、使用 setTimeout 替代 setInterval\n定时器指定的时间间隔，表示的是何时将定时器的代码添加到消息队列，而不是何时执行代码。所以真正何时执行代码的时间是不能保证的，它取决于何时被主线程的事件循环获取到，并执行\n假设有 `setInterval(function, 100)`，它的执行可能是这样的：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/30346ef998214cabb6c95141b19ad25f~tplv-k3u1fbpfcp-zoom-1.image)\n上图可见，setInterval 每隔 100ms 往队列中添加一个事件；100ms 后，添加 T1 定时器代码至队列中，主线程中还有任务在执行，所以等待，some event 执行结束后执行 T1 定时器代码；又过了100ms，T2定时器被添加到队列中，主线程还在执行 T1 代码，所以等待；又过了 100ms，理论上又要往队列里推一个定时器代码，但由于此时 T2 还在队列中，所以 T3 不会被添加，结果就是此时被跳过；然后，T1 定时器执行结束后马上执行了 T2 代码，所以并没有达到定时器间隔的效果\n综上所述，serInterval 有两个问题：\n-   可能多个定时器会连续执行（会导致后续的间隔误差）\n-   某些间隔会被跳过（这么设计也可能是为了尽量避免第一个问题）\n因而一般会使用 setTimeout 模拟 setInterval，来规避掉上面的缺点\n```\nsetTimeout(function fn() {\n// do something\nsetTimeout(fn, delay)\n}, delay)\n```\n这样的话，在前一个定时器代码执行完成前，不会向队列中插入新的定时器（不会连续执行），而且保证了定时器间隔\n注：有些说法，可能对当队列中存在定时器实例时，是否会跳过添加实例，存在质疑；还有的说法是，在 Node 环境中会跳过，在浏览器环境中会累加；不过我这边实测，不管在 Node 还是在 web 中，当队列中存在定时器实例时，都会跳过添加的；当然也有可能是浏览器版本或内核不同，表现不同，没有细测；感兴趣的小伙伴可以使用一下代码实测下，看是会一次性输出，还是会间隔性输出\n**这边顺便一提，涉及到做动画的场景可能会使用定时器**\n-   由于定时器的种种误差问题，以及固定时间间隔不一定与屏幕刷新时间相同，可能会引起丢帧；而且定时器在后台仍会继续执行，也会造成资源的浪费\n-   一般情况下，还是推荐使用 requestAnimationFrame，RAF 重绘或回流（重排）的时间间隔是紧紧跟随浏览器的刷新频率的；并且在页面未激活时，该页面的屏幕刷新任务也会被暂停，当页面被激活时，任务会从上次停留的地方继续执行，这也就意味着将耗费更少的资源，提升了性能\n### 总结\n-   setTimeout 和 setInterval 都存在计时误差，不会严格按照既定时间执行\n-   一般情况下，这些误差不会造成太大影响，只对于某些特殊场景，对时间要求比较严格的情况下，需要特殊处理\n-   对于 setInterval，个人建议能不用尽量不用，使用 setTimeout 的嵌套实现，可以规避掉一些潜在问题的发生\n'
      },{
        id: 22,
        name: '望舟',
        day: '1',
        category: '面试',
        title: '让“作用域和闭包”说人话！ ',
        intro: '让作用域和闭包说人话，面试时候有话可讲！',
        imgsrc: require('../assets/image/ArticleImg1.webp'),
        content:
        '# 一、作用域是什么\n作用域与编译原理息息相关，但是我们暂时还不用管编译原理的复杂过程，它的作用可以简单看下面这张图： \n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2dc72d14948848159ed01ab7af90a090~tplv-k3u1fbpfcp-zoom-1.image)\n简单来说就是“我得知道这些变量在哪里，不然我怎么取到它们再进行下一步操作呀！”\n***\nJavaScript的编译发生代码执行前的几微妙内，并不是发生在构建之前。\n引擎根据作用域进行变量查询，存在两种影响结果的查找方式——LHS/RHS。\nRHS（谁是源头【获取变量的值】）：需要找到这个变量的值才可以进行下一步操作。如console.log(a)，即得到a的值后执行操作。查询操作失败报ReferenceError异常，不合理操作报TypeError异常。\nLHS（目标是谁【对变量赋值】）：为操作找到一个容器，如var a = 2，即找到一个a，给它赋值为2。查询操作失败在非严格模式下会创建变量。*这个特性可以解释变量提升这个东西，也就是“赋值可以跑到声明前”。为了完成赋值这个动作，我可以自己声明一下嘛。现在可以暂时放一下这句话，等到提升时再想。*\n> ~~不推荐使用with/eval~~\n# 二、函数作用域和块作用域\n> 函数作用域含义：属于这个函数的全部变量都可以在整个函数的范围内使用或复用。\nfunction 开头的就是函数声明，其余则是函数表达式。 **正常函数声明被绑定在作用域中，函数表达式则绑定在函数自身中。** 这句话不理解可以先埋下一个伏笔，等下面看到闭包的时候再回头看会回味无穷。\n```\n// 函数声明\nfunction foo(){\nvar a = 2;\nconsole.log(a);\n}\nfoo()\n// 函数表达式\n(function foo(){\nvar a = 2;\nconsole.log(a);\n})()\nvar a = 2;\n(function IIFE(global){\nvar a = 3;\nconsole.log(a, global.a)// 3,2\n})(window)\n// 函数表达式\nvar foo = function(){\nconsole.log(1)\n}\n```\n那么怎么搞出一个块作用域呢？块作用域的声明方式有：\n1.  with 仅在with声明中有效\n1.  try/catch catch内的变量仅在catch内使用\n1.  let 劫持所在块的作用域\n1.  const 与let类似，变量不可修改\n块作用域的优势：1. 有利于垃圾回收（块作用域内代码执行后可以直接回收）；2. 解决 var 循环问题。\n# 三、提升\n> 没有赋值只有声明的变量是会报错 undefined，提升也只是提升了个声明而已；再换句话说，赋值可以跑在声明的前面。光说不干假把式~\n第一段代码可以顺利执行，因为对于 a 的声明会提升到最顶部，因此在作用域内能够找到a。但是这第二段代码中，`var a = 2;`会被拆分为两步，第一步是声明 a ，然后就执行了输出语句，还没有进行赋值呢，因此会出现报错。 这个例子恰好说明了“赋值可以跑在声明前面”。\n***\n例二：\n```\nfoo()\nfunction foo(){\nconsole.log(a); //undefined\nvar a;\n}\n```\n这里也是和例一一样，a会提升声明（作用域在foo内），但是只有声明，没有赋值，所以仍然会报错。\n***\n同样是声明提升，***函数的优先级高于变量***。这里的例子我们可以把函数表达式当作是一个变量的声明，相当于给foo2 这个变量赋值了一个函数。那么由于函数的优先级更高，这个foo2无法覆盖之前的foo1，所以输出仍然是1。\n# 四、闭包\n## 1. 闭包是什么\n首先我们得知道闭包是什么，来看看书里是怎么说的：\n> 函数在 定义时的词法作用域以外的地方 被调用，闭包使得函数可以继续访问定义时的词法作用域。\n这句话的形容使闭包看起来像一种_访问作用域的方法_。我们继续看下一句：\n> 无论通过何种手段将内部函数传递到所在的词法作用域以外，它都会持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包。\n**因此，不应该把比较理解成一种现象或者原理，应该作为一种工具方便我们使用来解决 JavaScript 中的一些问题。这是一个重要的理解点。** 用自己的话再来说一下闭包是什么吧：\n一个函数（A）引用着另一个函数的变量（B），即使 B 已经顺利执行结束了也不会被回收，因为 A 还引用着呢，所以 B 的各种变量也要被保存。\n'
      },{
        id: 23,
        name: 'ZEROL',
        day: '22',
        category: 'JavaScript',
        title: 'setTimeout 和 setInterval，你们两位同学注意点时间~ ',
        intro: '你们两位同学注意点时间~',
        imgsrc: require('../assets/image/ArticleImg2.webp'),
        content:
        '## 一、基本定义与用法 \n### 1、定义\n-   `setTimeout()`方法用于在指定的时间（单位毫秒）后执行回调函数或指定的一段代码\n-   `setInterval()`方法可按照指定的时间间隔（单位毫秒）来调用回调函数或指定的一段代码\n### 2、参数\n-   第一个参数 function，必填，回调函数。或者是一段字符串代码，但是这种方式不建议使用，就和使用`eval()`一样，有安全风险；而且还有作用域问题（字符串会在全局作用域内被解释执行）\n```\nsetTimeout(\'console.log(123);fn()\', 2000)\n```\n-   第二个参数 delay，可选，单位是 ms，对于`setTimeout`是延迟时间，对于`setInterval`是间隔时间，默认都是 0\n-   第三个参数 param1,param2,param3...，可选，是传递给回调函数的参数，不大常用\n ```\nsetTimeout(function (a, b) {\nconsole.log(a, b)\n}, 2000, \'我是\', \'定时器\')\n```\n### 3、返回值\n-   返回一个 ID（数字），可以将这个 ID 传递给`clearTimeout()`或`clearInterval()`来取消执行\n-   PS: `setTimeout()`和`setInterval()`共用一个编号池，技术上，`clearTimeout()`和`clearInterval()`可以互换使用，但是为了避免混淆，一般不这么做\n## 二、setTimeout 和 setInterval 的实际表现\n### 1、使用 setInterval 实现计时\n```\nconst startTime = new Date().getTime()\nlet count = 0\nconst interval = setInterval(function () {\ncount++\nconsole.log(new Date().getTime() - (startTime + count * 1000) + \'ms\')\nif(count === 10){\nclearInterval(interval);\n}\n}, 1000)\n```\n`new Date().getTime() - (startTime + count * 1000)`理想情况下应该是 0ms，然而事实并不是这样，而是存在着误差：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba8397cf6a184ed6a32b285693cff3c0~tplv-k3u1fbpfcp-zoom-1.image)\n### 2、使用 setTimeout 实现计时\n```\nconst startTime = new Date().getTime(), delay = 1000\nlet count = 0\nlet timer = setTimeout(doFunc, delay)\nfunction doFunc(){\ncount++\nconsole.log(new Date().getTime() - (startTime + count * 1000) + \'ms\')\nif(count < 10){\ntimer = setTimeout(doFunc, delay)\n}\n}\n```\nsetTimeout 也同样存在着误差，而且时间越来越大（setTimeout 需要在同步代码执行完成后才重新开始计时）：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c59850b3ac2a475eb718b5492630d88e~tplv-k3u1fbpfcp-zoom-1.image)\n## 三、为什么会出现误差\n### 1、setTimeout 的最短延迟时间\n`setTimeout`遵循的规范由 whatwg 来维护，在 [HTML Standard - 8.6 Timers](https://link.juejin.cn?target=https%3A%2F%2Fhtml.spec.whatwg.org%2Fmultipage%2Ftimers-and-user-prompts.html%23dom-settimeout "https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-settimeout") 中写到了定义定时器的详细步骤，其中有两条：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ffbfbab446fe494fb44c54181f48aa31~tplv-k3u1fbpfcp-zoom-1.image)\n上面的意思就是说，如果设置的 timeout 小于 0，则设置为 0，如果嵌套的层级超过了 5 层（计时器嵌套），并且 timeout 小于 4ms，则设置 timeout 为 4ms。并且，在不同浏览器中出现这种最小延迟的情况有所不同\n具体的源代码实现以及各大浏览器实现的不同，大家可以参考这篇文章：[为什么 setTimeout 有最小延时 4ms ？](https://link.juejin.cn?target=https%3A%2F%2Fwww.bruceyj.com%2Ffront-end-interview-summary%2Fsystem-design%2Fwhy-is-the-design%2F2-why-setTimeout-4ms.html "https://www.bruceyj.com/front-end-interview-summary/system-design/why-is-the-design/2-why-setTimeout-4ms.html")\n这里只看结论，定时器本身的定义步骤是造成其出现误差的原因之一\n### 2、setInterval 的最小间隔时间以及回调函数阻塞\n在 HTML5 标准中，setInterval 的最小间隔为 10ms，虽然我在规范文档中并未找到其相关说明，但是经过实际测试，也确实存在最小间隔时间，例如以下代码：\n```\nlet startTime = new Date().getTime()\nlet count = 0\nconst interval = setInterval(function () {\ncount++\n console.log(new Date().getTime() - startTime + \'ms\')\nstartTime = new Date().getTime()\nif(count === 10) {\nclearInterval(interval)\n}\n}, 0)\n```\n测试结果：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9bcffa807d384a7ab542fd1174186b12~tplv-k3u1fbpfcp-zoom-1.image)\n虽然没有 10ms 那么大的间隔，但是间隔仍然存在，猜测具体的间隔时间是和浏览器实现以及设备性能有关，无论如何，间隔是确实存在的\n另外，当使用 setInterval 时间间隔到点后，仅当队列中没有该定时器的任何其他代码实例时，才会将定时器的代码添加到队列中，如果有的话，则不会添加，造成堵塞，这个也与 JS 的事件循环有关\n### 3、未被激活的tabs的定时最小延迟 >= 1000ms\n为了优化后台 tab 的加载损耗（以及降低耗电量），在未被激活的 tab 中定时器的最小延时限制为1s(1000ms)，具体时间在不同的浏览器实现中也有差别\n### 4、JS 的事件循环机制\n`setTimeout`和`setInterval`中的时间并不是到点就立即执行，而是到点将其回调函数加入异步事件队列中，按照队列先进先出的性质，该回调函数到点之后是否能执行还得取决于是否属于队列首位，如果前头还有其他事件在等待，则不能按点执行，如果没有，则将其放入同步队列执行。具体事件循环机制，可以参考这篇文章：[动图学习-EventLoop](https://juejin.cn/post/6969028296893792286 "https://juejin.cn/post/6969028296893792286")\n## 四、解决方案\n### 1、在浏览器中实现一个 0ms 延时的定时器\n可以参考如下代码（来自于国外的一篇博客，也是 MDN 推荐的方法），主要是使用了 postMessage 方法，异步的执行了回调函数，并且速度要比 setTimeout(0) 要快的多。具体比较可以参照原文：[setTimeout with a shorter delay](https://link.juejin.cn?target=https%3A%2F%2Fdbaron.org%2Flog%2F20100309-faster-timeouts "https://dbaron.org/log/20100309-faster-timeouts")\n使用 setTimeout(0) 得到的时间：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8994a7da32e549cd9d06c34d1ac0bbc8~tplv-k3u1fbpfcp-zoom-1.image)\n将 setTimeout 改成 setZeroTimeout 后得到的时间，时间几乎都在 0～1，至于为什么不是绝对的 0，猜测可能与性能有关，总的来说，时间确实缩短了：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dced5471b7fc422d9f9eb28259b26ce2~tplv-k3u1fbpfcp-zoom-1.image)\n### 2、购物网站的秒杀活动\n一般情况下，从服务器拿到倒数时间后，前端的执行倒计时程序持续运行，事实上，显示时间相比实际时间会越来越慢的\n究其原因，倒计时通常是使用定时器实现，而 JS 的单线程特性使得同步任务执行过程中出现阻塞时，任务队列中的异步任务并不能及时执行，因此浏览器并不能保证在定时器设置的时间结束后代码总是被准时执行，从而造成了倒计时的偏差\n一般的解决方法是前端定时向服务器发送请求获取最新的时间差来校准倒计时时间，和用户一直按 F5 刷新没啥区别，比较简单粗暴，下面的方法可以一定程度上解决这个问题，纯前端控制，不依赖于后端。源地址已忘\n## 五、使用 setTimeout 替代 setInterval\n定时器指定的时间间隔，表示的是何时将定时器的代码添加到消息队列，而不是何时执行代码。所以真正何时执行代码的时间是不能保证的，它取决于何时被主线程的事件循环获取到，并执行\n假设有 `setInterval(function, 100)`，它的执行可能是这样的：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/30346ef998214cabb6c95141b19ad25f~tplv-k3u1fbpfcp-zoom-1.image)\n上图可见，setInterval 每隔 100ms 往队列中添加一个事件；100ms 后，添加 T1 定时器代码至队列中，主线程中还有任务在执行，所以等待，some event 执行结束后执行 T1 定时器代码；又过了100ms，T2定时器被添加到队列中，主线程还在执行 T1 代码，所以等待；又过了 100ms，理论上又要往队列里推一个定时器代码，但由于此时 T2 还在队列中，所以 T3 不会被添加，结果就是此时被跳过；然后，T1 定时器执行结束后马上执行了 T2 代码，所以并没有达到定时器间隔的效果\n综上所述，serInterval 有两个问题：\n-   可能多个定时器会连续执行（会导致后续的间隔误差）\n-   某些间隔会被跳过（这么设计也可能是为了尽量避免第一个问题）\n因而一般会使用 setTimeout 模拟 setInterval，来规避掉上面的缺点\n```\nsetTimeout(function fn() {\n// do something\nsetTimeout(fn, delay)\n}, delay)\n```\n这样的话，在前一个定时器代码执行完成前，不会向队列中插入新的定时器（不会连续执行），而且保证了定时器间隔\n注：有些说法，可能对当队列中存在定时器实例时，是否会跳过添加实例，存在质疑；还有的说法是，在 Node 环境中会跳过，在浏览器环境中会累加；不过我这边实测，不管在 Node 还是在 web 中，当队列中存在定时器实例时，都会跳过添加的；当然也有可能是浏览器版本或内核不同，表现不同，没有细测；感兴趣的小伙伴可以使用一下代码实测下，看是会一次性输出，还是会间隔性输出\n**这边顺便一提，涉及到做动画的场景可能会使用定时器**\n-   由于定时器的种种误差问题，以及固定时间间隔不一定与屏幕刷新时间相同，可能会引起丢帧；而且定时器在后台仍会继续执行，也会造成资源的浪费\n-   一般情况下，还是推荐使用 requestAnimationFrame，RAF 重绘或回流（重排）的时间间隔是紧紧跟随浏览器的刷新频率的；并且在页面未激活时，该页面的屏幕刷新任务也会被暂停，当页面被激活时，任务会从上次停留的地方继续执行，这也就意味着将耗费更少的资源，提升了性能\n### 总结\n-   setTimeout 和 setInterval 都存在计时误差，不会严格按照既定时间执行\n-   一般情况下，这些误差不会造成太大影响，只对于某些特殊场景，对时间要求比较严格的情况下，需要特殊处理\n-   对于 setInterval，个人建议能不用尽量不用，使用 setTimeout 的嵌套实现，可以规避掉一些潜在问题的发生\n'
      },{
        id: 24,
        name: '望舟',
        day: '1',
        category: '面试',
        title: '让“作用域和闭包”说人话！ ',
        intro: '让作用域和闭包说人话，面试时候有话可讲！',
        imgsrc: require('../assets/image/ArticleImg1.webp'),
        content:
        '# 一、作用域是什么\n作用域与编译原理息息相关，但是我们暂时还不用管编译原理的复杂过程，它的作用可以简单看下面这张图： \n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2dc72d14948848159ed01ab7af90a090~tplv-k3u1fbpfcp-zoom-1.image)\n简单来说就是“我得知道这些变量在哪里，不然我怎么取到它们再进行下一步操作呀！”\n***\nJavaScript的编译发生代码执行前的几微妙内，并不是发生在构建之前。\n引擎根据作用域进行变量查询，存在两种影响结果的查找方式——LHS/RHS。\nRHS（谁是源头【获取变量的值】）：需要找到这个变量的值才可以进行下一步操作。如console.log(a)，即得到a的值后执行操作。查询操作失败报ReferenceError异常，不合理操作报TypeError异常。\nLHS（目标是谁【对变量赋值】）：为操作找到一个容器，如var a = 2，即找到一个a，给它赋值为2。查询操作失败在非严格模式下会创建变量。*这个特性可以解释变量提升这个东西，也就是“赋值可以跑到声明前”。为了完成赋值这个动作，我可以自己声明一下嘛。现在可以暂时放一下这句话，等到提升时再想。*\n> ~~不推荐使用with/eval~~\n# 二、函数作用域和块作用域\n> 函数作用域含义：属于这个函数的全部变量都可以在整个函数的范围内使用或复用。\nfunction 开头的就是函数声明，其余则是函数表达式。 **正常函数声明被绑定在作用域中，函数表达式则绑定在函数自身中。** 这句话不理解可以先埋下一个伏笔，等下面看到闭包的时候再回头看会回味无穷。\n```\n// 函数声明\nfunction foo(){\nvar a = 2;\nconsole.log(a);\n}\nfoo()\n// 函数表达式\n(function foo(){\nvar a = 2;\nconsole.log(a);\n})()\nvar a = 2;\n(function IIFE(global){\nvar a = 3;\nconsole.log(a, global.a)// 3,2\n})(window)\n// 函数表达式\nvar foo = function(){\nconsole.log(1)\n}\n```\n那么怎么搞出一个块作用域呢？块作用域的声明方式有：\n1.  with 仅在with声明中有效\n1.  try/catch catch内的变量仅在catch内使用\n1.  let 劫持所在块的作用域\n1.  const 与let类似，变量不可修改\n块作用域的优势：1. 有利于垃圾回收（块作用域内代码执行后可以直接回收）；2. 解决 var 循环问题。\n# 三、提升\n> 没有赋值只有声明的变量是会报错 undefined，提升也只是提升了个声明而已；再换句话说，赋值可以跑在声明的前面。光说不干假把式~\n第一段代码可以顺利执行，因为对于 a 的声明会提升到最顶部，因此在作用域内能够找到a。但是这第二段代码中，`var a = 2;`会被拆分为两步，第一步是声明 a ，然后就执行了输出语句，还没有进行赋值呢，因此会出现报错。 这个例子恰好说明了“赋值可以跑在声明前面”。\n***\n例二：\n```\nfoo()\nfunction foo(){\nconsole.log(a); //undefined\nvar a;\n}\n```\n这里也是和例一一样，a会提升声明（作用域在foo内），但是只有声明，没有赋值，所以仍然会报错。\n***\n同样是声明提升，***函数的优先级高于变量***。这里的例子我们可以把函数表达式当作是一个变量的声明，相当于给foo2 这个变量赋值了一个函数。那么由于函数的优先级更高，这个foo2无法覆盖之前的foo1，所以输出仍然是1。\n# 四、闭包\n## 1. 闭包是什么\n首先我们得知道闭包是什么，来看看书里是怎么说的：\n> 函数在 定义时的词法作用域以外的地方 被调用，闭包使得函数可以继续访问定义时的词法作用域。\n这句话的形容使闭包看起来像一种_访问作用域的方法_。我们继续看下一句：\n> 无论通过何种手段将内部函数传递到所在的词法作用域以外，它都会持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包。\n**因此，不应该把比较理解成一种现象或者原理，应该作为一种工具方便我们使用来解决 JavaScript 中的一些问题。这是一个重要的理解点。** 用自己的话再来说一下闭包是什么吧：\n一个函数（A）引用着另一个函数的变量（B），即使 B 已经顺利执行结束了也不会被回收，因为 A 还引用着呢，所以 B 的各种变量也要被保存。\n'
      },{
        id: 25,
        name: 'ZEROL',
        day: '22',
        category: 'JavaScript',
        title: 'setTimeout 和 setInterval，你们两位同学注意点时间~ ',
        intro: '你们两位同学注意点时间~',
        imgsrc: require('../assets/image/ArticleImg2.webp'),
        content:
        '## 一、基本定义与用法 \n### 1、定义\n-   `setTimeout()`方法用于在指定的时间（单位毫秒）后执行回调函数或指定的一段代码\n-   `setInterval()`方法可按照指定的时间间隔（单位毫秒）来调用回调函数或指定的一段代码\n### 2、参数\n-   第一个参数 function，必填，回调函数。或者是一段字符串代码，但是这种方式不建议使用，就和使用`eval()`一样，有安全风险；而且还有作用域问题（字符串会在全局作用域内被解释执行）\n```\nsetTimeout(\'console.log(123);fn()\', 2000)\n```\n-   第二个参数 delay，可选，单位是 ms，对于`setTimeout`是延迟时间，对于`setInterval`是间隔时间，默认都是 0\n-   第三个参数 param1,param2,param3...，可选，是传递给回调函数的参数，不大常用\n ```\nsetTimeout(function (a, b) {\nconsole.log(a, b)\n}, 2000, \'我是\', \'定时器\')\n```\n### 3、返回值\n-   返回一个 ID（数字），可以将这个 ID 传递给`clearTimeout()`或`clearInterval()`来取消执行\n-   PS: `setTimeout()`和`setInterval()`共用一个编号池，技术上，`clearTimeout()`和`clearInterval()`可以互换使用，但是为了避免混淆，一般不这么做\n## 二、setTimeout 和 setInterval 的实际表现\n### 1、使用 setInterval 实现计时\n```\nconst startTime = new Date().getTime()\nlet count = 0\nconst interval = setInterval(function () {\ncount++\nconsole.log(new Date().getTime() - (startTime + count * 1000) + \'ms\')\nif(count === 10){\nclearInterval(interval);\n}\n}, 1000)\n```\n`new Date().getTime() - (startTime + count * 1000)`理想情况下应该是 0ms，然而事实并不是这样，而是存在着误差：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba8397cf6a184ed6a32b285693cff3c0~tplv-k3u1fbpfcp-zoom-1.image)\n### 2、使用 setTimeout 实现计时\n```\nconst startTime = new Date().getTime(), delay = 1000\nlet count = 0\nlet timer = setTimeout(doFunc, delay)\nfunction doFunc(){\ncount++\nconsole.log(new Date().getTime() - (startTime + count * 1000) + \'ms\')\nif(count < 10){\ntimer = setTimeout(doFunc, delay)\n}\n}\n```\nsetTimeout 也同样存在着误差，而且时间越来越大（setTimeout 需要在同步代码执行完成后才重新开始计时）：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c59850b3ac2a475eb718b5492630d88e~tplv-k3u1fbpfcp-zoom-1.image)\n## 三、为什么会出现误差\n### 1、setTimeout 的最短延迟时间\n`setTimeout`遵循的规范由 whatwg 来维护，在 [HTML Standard - 8.6 Timers](https://link.juejin.cn?target=https%3A%2F%2Fhtml.spec.whatwg.org%2Fmultipage%2Ftimers-and-user-prompts.html%23dom-settimeout "https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-settimeout") 中写到了定义定时器的详细步骤，其中有两条：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ffbfbab446fe494fb44c54181f48aa31~tplv-k3u1fbpfcp-zoom-1.image)\n上面的意思就是说，如果设置的 timeout 小于 0，则设置为 0，如果嵌套的层级超过了 5 层（计时器嵌套），并且 timeout 小于 4ms，则设置 timeout 为 4ms。并且，在不同浏览器中出现这种最小延迟的情况有所不同\n具体的源代码实现以及各大浏览器实现的不同，大家可以参考这篇文章：[为什么 setTimeout 有最小延时 4ms ？](https://link.juejin.cn?target=https%3A%2F%2Fwww.bruceyj.com%2Ffront-end-interview-summary%2Fsystem-design%2Fwhy-is-the-design%2F2-why-setTimeout-4ms.html "https://www.bruceyj.com/front-end-interview-summary/system-design/why-is-the-design/2-why-setTimeout-4ms.html")\n这里只看结论，定时器本身的定义步骤是造成其出现误差的原因之一\n### 2、setInterval 的最小间隔时间以及回调函数阻塞\n在 HTML5 标准中，setInterval 的最小间隔为 10ms，虽然我在规范文档中并未找到其相关说明，但是经过实际测试，也确实存在最小间隔时间，例如以下代码：\n```\nlet startTime = new Date().getTime()\nlet count = 0\nconst interval = setInterval(function () {\ncount++\n console.log(new Date().getTime() - startTime + \'ms\')\nstartTime = new Date().getTime()\nif(count === 10) {\nclearInterval(interval)\n}\n}, 0)\n```\n测试结果：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9bcffa807d384a7ab542fd1174186b12~tplv-k3u1fbpfcp-zoom-1.image)\n虽然没有 10ms 那么大的间隔，但是间隔仍然存在，猜测具体的间隔时间是和浏览器实现以及设备性能有关，无论如何，间隔是确实存在的\n另外，当使用 setInterval 时间间隔到点后，仅当队列中没有该定时器的任何其他代码实例时，才会将定时器的代码添加到队列中，如果有的话，则不会添加，造成堵塞，这个也与 JS 的事件循环有关\n### 3、未被激活的tabs的定时最小延迟 >= 1000ms\n为了优化后台 tab 的加载损耗（以及降低耗电量），在未被激活的 tab 中定时器的最小延时限制为1s(1000ms)，具体时间在不同的浏览器实现中也有差别\n### 4、JS 的事件循环机制\n`setTimeout`和`setInterval`中的时间并不是到点就立即执行，而是到点将其回调函数加入异步事件队列中，按照队列先进先出的性质，该回调函数到点之后是否能执行还得取决于是否属于队列首位，如果前头还有其他事件在等待，则不能按点执行，如果没有，则将其放入同步队列执行。具体事件循环机制，可以参考这篇文章：[动图学习-EventLoop](https://juejin.cn/post/6969028296893792286 "https://juejin.cn/post/6969028296893792286")\n## 四、解决方案\n### 1、在浏览器中实现一个 0ms 延时的定时器\n可以参考如下代码（来自于国外的一篇博客，也是 MDN 推荐的方法），主要是使用了 postMessage 方法，异步的执行了回调函数，并且速度要比 setTimeout(0) 要快的多。具体比较可以参照原文：[setTimeout with a shorter delay](https://link.juejin.cn?target=https%3A%2F%2Fdbaron.org%2Flog%2F20100309-faster-timeouts "https://dbaron.org/log/20100309-faster-timeouts")\n使用 setTimeout(0) 得到的时间：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8994a7da32e549cd9d06c34d1ac0bbc8~tplv-k3u1fbpfcp-zoom-1.image)\n将 setTimeout 改成 setZeroTimeout 后得到的时间，时间几乎都在 0～1，至于为什么不是绝对的 0，猜测可能与性能有关，总的来说，时间确实缩短了：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dced5471b7fc422d9f9eb28259b26ce2~tplv-k3u1fbpfcp-zoom-1.image)\n### 2、购物网站的秒杀活动\n一般情况下，从服务器拿到倒数时间后，前端的执行倒计时程序持续运行，事实上，显示时间相比实际时间会越来越慢的\n究其原因，倒计时通常是使用定时器实现，而 JS 的单线程特性使得同步任务执行过程中出现阻塞时，任务队列中的异步任务并不能及时执行，因此浏览器并不能保证在定时器设置的时间结束后代码总是被准时执行，从而造成了倒计时的偏差\n一般的解决方法是前端定时向服务器发送请求获取最新的时间差来校准倒计时时间，和用户一直按 F5 刷新没啥区别，比较简单粗暴，下面的方法可以一定程度上解决这个问题，纯前端控制，不依赖于后端。源地址已忘\n## 五、使用 setTimeout 替代 setInterval\n定时器指定的时间间隔，表示的是何时将定时器的代码添加到消息队列，而不是何时执行代码。所以真正何时执行代码的时间是不能保证的，它取决于何时被主线程的事件循环获取到，并执行\n假设有 `setInterval(function, 100)`，它的执行可能是这样的：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/30346ef998214cabb6c95141b19ad25f~tplv-k3u1fbpfcp-zoom-1.image)\n上图可见，setInterval 每隔 100ms 往队列中添加一个事件；100ms 后，添加 T1 定时器代码至队列中，主线程中还有任务在执行，所以等待，some event 执行结束后执行 T1 定时器代码；又过了100ms，T2定时器被添加到队列中，主线程还在执行 T1 代码，所以等待；又过了 100ms，理论上又要往队列里推一个定时器代码，但由于此时 T2 还在队列中，所以 T3 不会被添加，结果就是此时被跳过；然后，T1 定时器执行结束后马上执行了 T2 代码，所以并没有达到定时器间隔的效果\n综上所述，serInterval 有两个问题：\n-   可能多个定时器会连续执行（会导致后续的间隔误差）\n-   某些间隔会被跳过（这么设计也可能是为了尽量避免第一个问题）\n因而一般会使用 setTimeout 模拟 setInterval，来规避掉上面的缺点\n```\nsetTimeout(function fn() {\n// do something\nsetTimeout(fn, delay)\n}, delay)\n```\n这样的话，在前一个定时器代码执行完成前，不会向队列中插入新的定时器（不会连续执行），而且保证了定时器间隔\n注：有些说法，可能对当队列中存在定时器实例时，是否会跳过添加实例，存在质疑；还有的说法是，在 Node 环境中会跳过，在浏览器环境中会累加；不过我这边实测，不管在 Node 还是在 web 中，当队列中存在定时器实例时，都会跳过添加的；当然也有可能是浏览器版本或内核不同，表现不同，没有细测；感兴趣的小伙伴可以使用一下代码实测下，看是会一次性输出，还是会间隔性输出\n**这边顺便一提，涉及到做动画的场景可能会使用定时器**\n-   由于定时器的种种误差问题，以及固定时间间隔不一定与屏幕刷新时间相同，可能会引起丢帧；而且定时器在后台仍会继续执行，也会造成资源的浪费\n-   一般情况下，还是推荐使用 requestAnimationFrame，RAF 重绘或回流（重排）的时间间隔是紧紧跟随浏览器的刷新频率的；并且在页面未激活时，该页面的屏幕刷新任务也会被暂停，当页面被激活时，任务会从上次停留的地方继续执行，这也就意味着将耗费更少的资源，提升了性能\n### 总结\n-   setTimeout 和 setInterval 都存在计时误差，不会严格按照既定时间执行\n-   一般情况下，这些误差不会造成太大影响，只对于某些特殊场景，对时间要求比较严格的情况下，需要特殊处理\n-   对于 setInterval，个人建议能不用尽量不用，使用 setTimeout 的嵌套实现，可以规避掉一些潜在问题的发生\n'
      },{
        id: 26,
        name: '望舟',
        day: '1',
        category: '面试',
        title: '让“作用域和闭包”说人话！ ',
        intro: '让作用域和闭包说人话，面试时候有话可讲！',
        imgsrc: require('../assets/image/ArticleImg1.webp'),
        content:
        '# 一、作用域是什么\n作用域与编译原理息息相关，但是我们暂时还不用管编译原理的复杂过程，它的作用可以简单看下面这张图： \n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2dc72d14948848159ed01ab7af90a090~tplv-k3u1fbpfcp-zoom-1.image)\n简单来说就是“我得知道这些变量在哪里，不然我怎么取到它们再进行下一步操作呀！”\n***\nJavaScript的编译发生代码执行前的几微妙内，并不是发生在构建之前。\n引擎根据作用域进行变量查询，存在两种影响结果的查找方式——LHS/RHS。\nRHS（谁是源头【获取变量的值】）：需要找到这个变量的值才可以进行下一步操作。如console.log(a)，即得到a的值后执行操作。查询操作失败报ReferenceError异常，不合理操作报TypeError异常。\nLHS（目标是谁【对变量赋值】）：为操作找到一个容器，如var a = 2，即找到一个a，给它赋值为2。查询操作失败在非严格模式下会创建变量。*这个特性可以解释变量提升这个东西，也就是“赋值可以跑到声明前”。为了完成赋值这个动作，我可以自己声明一下嘛。现在可以暂时放一下这句话，等到提升时再想。*\n> ~~不推荐使用with/eval~~\n# 二、函数作用域和块作用域\n> 函数作用域含义：属于这个函数的全部变量都可以在整个函数的范围内使用或复用。\nfunction 开头的就是函数声明，其余则是函数表达式。 **正常函数声明被绑定在作用域中，函数表达式则绑定在函数自身中。** 这句话不理解可以先埋下一个伏笔，等下面看到闭包的时候再回头看会回味无穷。\n```\n// 函数声明\nfunction foo(){\nvar a = 2;\nconsole.log(a);\n}\nfoo()\n// 函数表达式\n(function foo(){\nvar a = 2;\nconsole.log(a);\n})()\nvar a = 2;\n(function IIFE(global){\nvar a = 3;\nconsole.log(a, global.a)// 3,2\n})(window)\n// 函数表达式\nvar foo = function(){\nconsole.log(1)\n}\n```\n那么怎么搞出一个块作用域呢？块作用域的声明方式有：\n1.  with 仅在with声明中有效\n1.  try/catch catch内的变量仅在catch内使用\n1.  let 劫持所在块的作用域\n1.  const 与let类似，变量不可修改\n块作用域的优势：1. 有利于垃圾回收（块作用域内代码执行后可以直接回收）；2. 解决 var 循环问题。\n# 三、提升\n> 没有赋值只有声明的变量是会报错 undefined，提升也只是提升了个声明而已；再换句话说，赋值可以跑在声明的前面。光说不干假把式~\n第一段代码可以顺利执行，因为对于 a 的声明会提升到最顶部，因此在作用域内能够找到a。但是这第二段代码中，`var a = 2;`会被拆分为两步，第一步是声明 a ，然后就执行了输出语句，还没有进行赋值呢，因此会出现报错。 这个例子恰好说明了“赋值可以跑在声明前面”。\n***\n例二：\n```\nfoo()\nfunction foo(){\nconsole.log(a); //undefined\nvar a;\n}\n```\n这里也是和例一一样，a会提升声明（作用域在foo内），但是只有声明，没有赋值，所以仍然会报错。\n***\n同样是声明提升，***函数的优先级高于变量***。这里的例子我们可以把函数表达式当作是一个变量的声明，相当于给foo2 这个变量赋值了一个函数。那么由于函数的优先级更高，这个foo2无法覆盖之前的foo1，所以输出仍然是1。\n# 四、闭包\n## 1. 闭包是什么\n首先我们得知道闭包是什么，来看看书里是怎么说的：\n> 函数在 定义时的词法作用域以外的地方 被调用，闭包使得函数可以继续访问定义时的词法作用域。\n这句话的形容使闭包看起来像一种_访问作用域的方法_。我们继续看下一句：\n> 无论通过何种手段将内部函数传递到所在的词法作用域以外，它都会持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包。\n**因此，不应该把比较理解成一种现象或者原理，应该作为一种工具方便我们使用来解决 JavaScript 中的一些问题。这是一个重要的理解点。** 用自己的话再来说一下闭包是什么吧：\n一个函数（A）引用着另一个函数的变量（B），即使 B 已经顺利执行结束了也不会被回收，因为 A 还引用着呢，所以 B 的各种变量也要被保存。\n'
      },{
        id: 27,
        name: 'ZEROL',
        day: '22',
        category: 'JavaScript',
        title: 'setTimeout 和 setInterval，你们两位同学注意点时间~ ',
        intro: '你们两位同学注意点时间~',
        imgsrc: require('../assets/image/ArticleImg2.webp'),
        content:
        '## 一、基本定义与用法 \n### 1、定义\n-   `setTimeout()`方法用于在指定的时间（单位毫秒）后执行回调函数或指定的一段代码\n-   `setInterval()`方法可按照指定的时间间隔（单位毫秒）来调用回调函数或指定的一段代码\n### 2、参数\n-   第一个参数 function，必填，回调函数。或者是一段字符串代码，但是这种方式不建议使用，就和使用`eval()`一样，有安全风险；而且还有作用域问题（字符串会在全局作用域内被解释执行）\n```\nsetTimeout(\'console.log(123);fn()\', 2000)\n```\n-   第二个参数 delay，可选，单位是 ms，对于`setTimeout`是延迟时间，对于`setInterval`是间隔时间，默认都是 0\n-   第三个参数 param1,param2,param3...，可选，是传递给回调函数的参数，不大常用\n ```\nsetTimeout(function (a, b) {\nconsole.log(a, b)\n}, 2000, \'我是\', \'定时器\')\n```\n### 3、返回值\n-   返回一个 ID（数字），可以将这个 ID 传递给`clearTimeout()`或`clearInterval()`来取消执行\n-   PS: `setTimeout()`和`setInterval()`共用一个编号池，技术上，`clearTimeout()`和`clearInterval()`可以互换使用，但是为了避免混淆，一般不这么做\n## 二、setTimeout 和 setInterval 的实际表现\n### 1、使用 setInterval 实现计时\n```\nconst startTime = new Date().getTime()\nlet count = 0\nconst interval = setInterval(function () {\ncount++\nconsole.log(new Date().getTime() - (startTime + count * 1000) + \'ms\')\nif(count === 10){\nclearInterval(interval);\n}\n}, 1000)\n```\n`new Date().getTime() - (startTime + count * 1000)`理想情况下应该是 0ms，然而事实并不是这样，而是存在着误差：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba8397cf6a184ed6a32b285693cff3c0~tplv-k3u1fbpfcp-zoom-1.image)\n### 2、使用 setTimeout 实现计时\n```\nconst startTime = new Date().getTime(), delay = 1000\nlet count = 0\nlet timer = setTimeout(doFunc, delay)\nfunction doFunc(){\ncount++\nconsole.log(new Date().getTime() - (startTime + count * 1000) + \'ms\')\nif(count < 10){\ntimer = setTimeout(doFunc, delay)\n}\n}\n```\nsetTimeout 也同样存在着误差，而且时间越来越大（setTimeout 需要在同步代码执行完成后才重新开始计时）：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c59850b3ac2a475eb718b5492630d88e~tplv-k3u1fbpfcp-zoom-1.image)\n## 三、为什么会出现误差\n### 1、setTimeout 的最短延迟时间\n`setTimeout`遵循的规范由 whatwg 来维护，在 [HTML Standard - 8.6 Timers](https://link.juejin.cn?target=https%3A%2F%2Fhtml.spec.whatwg.org%2Fmultipage%2Ftimers-and-user-prompts.html%23dom-settimeout "https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-settimeout") 中写到了定义定时器的详细步骤，其中有两条：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ffbfbab446fe494fb44c54181f48aa31~tplv-k3u1fbpfcp-zoom-1.image)\n上面的意思就是说，如果设置的 timeout 小于 0，则设置为 0，如果嵌套的层级超过了 5 层（计时器嵌套），并且 timeout 小于 4ms，则设置 timeout 为 4ms。并且，在不同浏览器中出现这种最小延迟的情况有所不同\n具体的源代码实现以及各大浏览器实现的不同，大家可以参考这篇文章：[为什么 setTimeout 有最小延时 4ms ？](https://link.juejin.cn?target=https%3A%2F%2Fwww.bruceyj.com%2Ffront-end-interview-summary%2Fsystem-design%2Fwhy-is-the-design%2F2-why-setTimeout-4ms.html "https://www.bruceyj.com/front-end-interview-summary/system-design/why-is-the-design/2-why-setTimeout-4ms.html")\n这里只看结论，定时器本身的定义步骤是造成其出现误差的原因之一\n### 2、setInterval 的最小间隔时间以及回调函数阻塞\n在 HTML5 标准中，setInterval 的最小间隔为 10ms，虽然我在规范文档中并未找到其相关说明，但是经过实际测试，也确实存在最小间隔时间，例如以下代码：\n```\nlet startTime = new Date().getTime()\nlet count = 0\nconst interval = setInterval(function () {\ncount++\n console.log(new Date().getTime() - startTime + \'ms\')\nstartTime = new Date().getTime()\nif(count === 10) {\nclearInterval(interval)\n}\n}, 0)\n```\n测试结果：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9bcffa807d384a7ab542fd1174186b12~tplv-k3u1fbpfcp-zoom-1.image)\n虽然没有 10ms 那么大的间隔，但是间隔仍然存在，猜测具体的间隔时间是和浏览器实现以及设备性能有关，无论如何，间隔是确实存在的\n另外，当使用 setInterval 时间间隔到点后，仅当队列中没有该定时器的任何其他代码实例时，才会将定时器的代码添加到队列中，如果有的话，则不会添加，造成堵塞，这个也与 JS 的事件循环有关\n### 3、未被激活的tabs的定时最小延迟 >= 1000ms\n为了优化后台 tab 的加载损耗（以及降低耗电量），在未被激活的 tab 中定时器的最小延时限制为1s(1000ms)，具体时间在不同的浏览器实现中也有差别\n### 4、JS 的事件循环机制\n`setTimeout`和`setInterval`中的时间并不是到点就立即执行，而是到点将其回调函数加入异步事件队列中，按照队列先进先出的性质，该回调函数到点之后是否能执行还得取决于是否属于队列首位，如果前头还有其他事件在等待，则不能按点执行，如果没有，则将其放入同步队列执行。具体事件循环机制，可以参考这篇文章：[动图学习-EventLoop](https://juejin.cn/post/6969028296893792286 "https://juejin.cn/post/6969028296893792286")\n## 四、解决方案\n### 1、在浏览器中实现一个 0ms 延时的定时器\n可以参考如下代码（来自于国外的一篇博客，也是 MDN 推荐的方法），主要是使用了 postMessage 方法，异步的执行了回调函数，并且速度要比 setTimeout(0) 要快的多。具体比较可以参照原文：[setTimeout with a shorter delay](https://link.juejin.cn?target=https%3A%2F%2Fdbaron.org%2Flog%2F20100309-faster-timeouts "https://dbaron.org/log/20100309-faster-timeouts")\n使用 setTimeout(0) 得到的时间：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8994a7da32e549cd9d06c34d1ac0bbc8~tplv-k3u1fbpfcp-zoom-1.image)\n将 setTimeout 改成 setZeroTimeout 后得到的时间，时间几乎都在 0～1，至于为什么不是绝对的 0，猜测可能与性能有关，总的来说，时间确实缩短了：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dced5471b7fc422d9f9eb28259b26ce2~tplv-k3u1fbpfcp-zoom-1.image)\n### 2、购物网站的秒杀活动\n一般情况下，从服务器拿到倒数时间后，前端的执行倒计时程序持续运行，事实上，显示时间相比实际时间会越来越慢的\n究其原因，倒计时通常是使用定时器实现，而 JS 的单线程特性使得同步任务执行过程中出现阻塞时，任务队列中的异步任务并不能及时执行，因此浏览器并不能保证在定时器设置的时间结束后代码总是被准时执行，从而造成了倒计时的偏差\n一般的解决方法是前端定时向服务器发送请求获取最新的时间差来校准倒计时时间，和用户一直按 F5 刷新没啥区别，比较简单粗暴，下面的方法可以一定程度上解决这个问题，纯前端控制，不依赖于后端。源地址已忘\n## 五、使用 setTimeout 替代 setInterval\n定时器指定的时间间隔，表示的是何时将定时器的代码添加到消息队列，而不是何时执行代码。所以真正何时执行代码的时间是不能保证的，它取决于何时被主线程的事件循环获取到，并执行\n假设有 `setInterval(function, 100)`，它的执行可能是这样的：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/30346ef998214cabb6c95141b19ad25f~tplv-k3u1fbpfcp-zoom-1.image)\n上图可见，setInterval 每隔 100ms 往队列中添加一个事件；100ms 后，添加 T1 定时器代码至队列中，主线程中还有任务在执行，所以等待，some event 执行结束后执行 T1 定时器代码；又过了100ms，T2定时器被添加到队列中，主线程还在执行 T1 代码，所以等待；又过了 100ms，理论上又要往队列里推一个定时器代码，但由于此时 T2 还在队列中，所以 T3 不会被添加，结果就是此时被跳过；然后，T1 定时器执行结束后马上执行了 T2 代码，所以并没有达到定时器间隔的效果\n综上所述，serInterval 有两个问题：\n-   可能多个定时器会连续执行（会导致后续的间隔误差）\n-   某些间隔会被跳过（这么设计也可能是为了尽量避免第一个问题）\n因而一般会使用 setTimeout 模拟 setInterval，来规避掉上面的缺点\n```\nsetTimeout(function fn() {\n// do something\nsetTimeout(fn, delay)\n}, delay)\n```\n这样的话，在前一个定时器代码执行完成前，不会向队列中插入新的定时器（不会连续执行），而且保证了定时器间隔\n注：有些说法，可能对当队列中存在定时器实例时，是否会跳过添加实例，存在质疑；还有的说法是，在 Node 环境中会跳过，在浏览器环境中会累加；不过我这边实测，不管在 Node 还是在 web 中，当队列中存在定时器实例时，都会跳过添加的；当然也有可能是浏览器版本或内核不同，表现不同，没有细测；感兴趣的小伙伴可以使用一下代码实测下，看是会一次性输出，还是会间隔性输出\n**这边顺便一提，涉及到做动画的场景可能会使用定时器**\n-   由于定时器的种种误差问题，以及固定时间间隔不一定与屏幕刷新时间相同，可能会引起丢帧；而且定时器在后台仍会继续执行，也会造成资源的浪费\n-   一般情况下，还是推荐使用 requestAnimationFrame，RAF 重绘或回流（重排）的时间间隔是紧紧跟随浏览器的刷新频率的；并且在页面未激活时，该页面的屏幕刷新任务也会被暂停，当页面被激活时，任务会从上次停留的地方继续执行，这也就意味着将耗费更少的资源，提升了性能\n### 总结\n-   setTimeout 和 setInterval 都存在计时误差，不会严格按照既定时间执行\n-   一般情况下，这些误差不会造成太大影响，只对于某些特殊场景，对时间要求比较严格的情况下，需要特殊处理\n-   对于 setInterval，个人建议能不用尽量不用，使用 setTimeout 的嵌套实现，可以规避掉一些潜在问题的发生\n'
      },{
        id: 28,
        name: 'ZEROL',
        day: '22',
        category: 'JavaScript',
        title: 'setTimeout 和 setInterval，你们两位同学注意点时间~ ',
        intro: '你们两位同学注意点时间~',
        imgsrc: require('../assets/image/ArticleImg2.webp'),
        content:
        '## 一、基本定义与用法 \n### 1、定义\n-   `setTimeout()`方法用于在指定的时间（单位毫秒）后执行回调函数或指定的一段代码\n-   `setInterval()`方法可按照指定的时间间隔（单位毫秒）来调用回调函数或指定的一段代码\n### 2、参数\n-   第一个参数 function，必填，回调函数。或者是一段字符串代码，但是这种方式不建议使用，就和使用`eval()`一样，有安全风险；而且还有作用域问题（字符串会在全局作用域内被解释执行）\n```\nsetTimeout(\'console.log(123);fn()\', 2000)\n```\n-   第二个参数 delay，可选，单位是 ms，对于`setTimeout`是延迟时间，对于`setInterval`是间隔时间，默认都是 0\n-   第三个参数 param1,param2,param3...，可选，是传递给回调函数的参数，不大常用\n ```\nsetTimeout(function (a, b) {\nconsole.log(a, b)\n}, 2000, \'我是\', \'定时器\')\n```\n### 3、返回值\n-   返回一个 ID（数字），可以将这个 ID 传递给`clearTimeout()`或`clearInterval()`来取消执行\n-   PS: `setTimeout()`和`setInterval()`共用一个编号池，技术上，`clearTimeout()`和`clearInterval()`可以互换使用，但是为了避免混淆，一般不这么做\n## 二、setTimeout 和 setInterval 的实际表现\n### 1、使用 setInterval 实现计时\n```\nconst startTime = new Date().getTime()\nlet count = 0\nconst interval = setInterval(function () {\ncount++\nconsole.log(new Date().getTime() - (startTime + count * 1000) + \'ms\')\nif(count === 10){\nclearInterval(interval);\n}\n}, 1000)\n```\n`new Date().getTime() - (startTime + count * 1000)`理想情况下应该是 0ms，然而事实并不是这样，而是存在着误差：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba8397cf6a184ed6a32b285693cff3c0~tplv-k3u1fbpfcp-zoom-1.image)\n### 2、使用 setTimeout 实现计时\n```\nconst startTime = new Date().getTime(), delay = 1000\nlet count = 0\nlet timer = setTimeout(doFunc, delay)\nfunction doFunc(){\ncount++\nconsole.log(new Date().getTime() - (startTime + count * 1000) + \'ms\')\nif(count < 10){\ntimer = setTimeout(doFunc, delay)\n}\n}\n```\nsetTimeout 也同样存在着误差，而且时间越来越大（setTimeout 需要在同步代码执行完成后才重新开始计时）：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c59850b3ac2a475eb718b5492630d88e~tplv-k3u1fbpfcp-zoom-1.image)\n## 三、为什么会出现误差\n### 1、setTimeout 的最短延迟时间\n`setTimeout`遵循的规范由 whatwg 来维护，在 [HTML Standard - 8.6 Timers](https://link.juejin.cn?target=https%3A%2F%2Fhtml.spec.whatwg.org%2Fmultipage%2Ftimers-and-user-prompts.html%23dom-settimeout "https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-settimeout") 中写到了定义定时器的详细步骤，其中有两条：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ffbfbab446fe494fb44c54181f48aa31~tplv-k3u1fbpfcp-zoom-1.image)\n上面的意思就是说，如果设置的 timeout 小于 0，则设置为 0，如果嵌套的层级超过了 5 层（计时器嵌套），并且 timeout 小于 4ms，则设置 timeout 为 4ms。并且，在不同浏览器中出现这种最小延迟的情况有所不同\n具体的源代码实现以及各大浏览器实现的不同，大家可以参考这篇文章：[为什么 setTimeout 有最小延时 4ms ？](https://link.juejin.cn?target=https%3A%2F%2Fwww.bruceyj.com%2Ffront-end-interview-summary%2Fsystem-design%2Fwhy-is-the-design%2F2-why-setTimeout-4ms.html "https://www.bruceyj.com/front-end-interview-summary/system-design/why-is-the-design/2-why-setTimeout-4ms.html")\n这里只看结论，定时器本身的定义步骤是造成其出现误差的原因之一\n### 2、setInterval 的最小间隔时间以及回调函数阻塞\n在 HTML5 标准中，setInterval 的最小间隔为 10ms，虽然我在规范文档中并未找到其相关说明，但是经过实际测试，也确实存在最小间隔时间，例如以下代码：\n```\nlet startTime = new Date().getTime()\nlet count = 0\nconst interval = setInterval(function () {\ncount++\n console.log(new Date().getTime() - startTime + \'ms\')\nstartTime = new Date().getTime()\nif(count === 10) {\nclearInterval(interval)\n}\n}, 0)\n```\n测试结果：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9bcffa807d384a7ab542fd1174186b12~tplv-k3u1fbpfcp-zoom-1.image)\n虽然没有 10ms 那么大的间隔，但是间隔仍然存在，猜测具体的间隔时间是和浏览器实现以及设备性能有关，无论如何，间隔是确实存在的\n另外，当使用 setInterval 时间间隔到点后，仅当队列中没有该定时器的任何其他代码实例时，才会将定时器的代码添加到队列中，如果有的话，则不会添加，造成堵塞，这个也与 JS 的事件循环有关\n### 3、未被激活的tabs的定时最小延迟 >= 1000ms\n为了优化后台 tab 的加载损耗（以及降低耗电量），在未被激活的 tab 中定时器的最小延时限制为1s(1000ms)，具体时间在不同的浏览器实现中也有差别\n### 4、JS 的事件循环机制\n`setTimeout`和`setInterval`中的时间并不是到点就立即执行，而是到点将其回调函数加入异步事件队列中，按照队列先进先出的性质，该回调函数到点之后是否能执行还得取决于是否属于队列首位，如果前头还有其他事件在等待，则不能按点执行，如果没有，则将其放入同步队列执行。具体事件循环机制，可以参考这篇文章：[动图学习-EventLoop](https://juejin.cn/post/6969028296893792286 "https://juejin.cn/post/6969028296893792286")\n## 四、解决方案\n### 1、在浏览器中实现一个 0ms 延时的定时器\n可以参考如下代码（来自于国外的一篇博客，也是 MDN 推荐的方法），主要是使用了 postMessage 方法，异步的执行了回调函数，并且速度要比 setTimeout(0) 要快的多。具体比较可以参照原文：[setTimeout with a shorter delay](https://link.juejin.cn?target=https%3A%2F%2Fdbaron.org%2Flog%2F20100309-faster-timeouts "https://dbaron.org/log/20100309-faster-timeouts")\n使用 setTimeout(0) 得到的时间：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8994a7da32e549cd9d06c34d1ac0bbc8~tplv-k3u1fbpfcp-zoom-1.image)\n将 setTimeout 改成 setZeroTimeout 后得到的时间，时间几乎都在 0～1，至于为什么不是绝对的 0，猜测可能与性能有关，总的来说，时间确实缩短了：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dced5471b7fc422d9f9eb28259b26ce2~tplv-k3u1fbpfcp-zoom-1.image)\n### 2、购物网站的秒杀活动\n一般情况下，从服务器拿到倒数时间后，前端的执行倒计时程序持续运行，事实上，显示时间相比实际时间会越来越慢的\n究其原因，倒计时通常是使用定时器实现，而 JS 的单线程特性使得同步任务执行过程中出现阻塞时，任务队列中的异步任务并不能及时执行，因此浏览器并不能保证在定时器设置的时间结束后代码总是被准时执行，从而造成了倒计时的偏差\n一般的解决方法是前端定时向服务器发送请求获取最新的时间差来校准倒计时时间，和用户一直按 F5 刷新没啥区别，比较简单粗暴，下面的方法可以一定程度上解决这个问题，纯前端控制，不依赖于后端。源地址已忘\n## 五、使用 setTimeout 替代 setInterval\n定时器指定的时间间隔，表示的是何时将定时器的代码添加到消息队列，而不是何时执行代码。所以真正何时执行代码的时间是不能保证的，它取决于何时被主线程的事件循环获取到，并执行\n假设有 `setInterval(function, 100)`，它的执行可能是这样的：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/30346ef998214cabb6c95141b19ad25f~tplv-k3u1fbpfcp-zoom-1.image)\n上图可见，setInterval 每隔 100ms 往队列中添加一个事件；100ms 后，添加 T1 定时器代码至队列中，主线程中还有任务在执行，所以等待，some event 执行结束后执行 T1 定时器代码；又过了100ms，T2定时器被添加到队列中，主线程还在执行 T1 代码，所以等待；又过了 100ms，理论上又要往队列里推一个定时器代码，但由于此时 T2 还在队列中，所以 T3 不会被添加，结果就是此时被跳过；然后，T1 定时器执行结束后马上执行了 T2 代码，所以并没有达到定时器间隔的效果\n综上所述，serInterval 有两个问题：\n-   可能多个定时器会连续执行（会导致后续的间隔误差）\n-   某些间隔会被跳过（这么设计也可能是为了尽量避免第一个问题）\n因而一般会使用 setTimeout 模拟 setInterval，来规避掉上面的缺点\n```\nsetTimeout(function fn() {\n// do something\nsetTimeout(fn, delay)\n}, delay)\n```\n这样的话，在前一个定时器代码执行完成前，不会向队列中插入新的定时器（不会连续执行），而且保证了定时器间隔\n注：有些说法，可能对当队列中存在定时器实例时，是否会跳过添加实例，存在质疑；还有的说法是，在 Node 环境中会跳过，在浏览器环境中会累加；不过我这边实测，不管在 Node 还是在 web 中，当队列中存在定时器实例时，都会跳过添加的；当然也有可能是浏览器版本或内核不同，表现不同，没有细测；感兴趣的小伙伴可以使用一下代码实测下，看是会一次性输出，还是会间隔性输出\n**这边顺便一提，涉及到做动画的场景可能会使用定时器**\n-   由于定时器的种种误差问题，以及固定时间间隔不一定与屏幕刷新时间相同，可能会引起丢帧；而且定时器在后台仍会继续执行，也会造成资源的浪费\n-   一般情况下，还是推荐使用 requestAnimationFrame，RAF 重绘或回流（重排）的时间间隔是紧紧跟随浏览器的刷新频率的；并且在页面未激活时，该页面的屏幕刷新任务也会被暂停，当页面被激活时，任务会从上次停留的地方继续执行，这也就意味着将耗费更少的资源，提升了性能\n### 总结\n-   setTimeout 和 setInterval 都存在计时误差，不会严格按照既定时间执行\n-   一般情况下，这些误差不会造成太大影响，只对于某些特殊场景，对时间要求比较严格的情况下，需要特殊处理\n-   对于 setInterval，个人建议能不用尽量不用，使用 setTimeout 的嵌套实现，可以规避掉一些潜在问题的发生\n'
      },{
        id: 29,
        name: '望舟',
        day: '1',
        category: '面试',
        title: '让“作用域和闭包”说人话！ ',
        intro: '让作用域和闭包说人话，面试时候有话可讲！',
        imgsrc: require('../assets/image/ArticleImg1.webp'),
        content:
        '# 一、作用域是什么\n作用域与编译原理息息相关，但是我们暂时还不用管编译原理的复杂过程，它的作用可以简单看下面这张图： \n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2dc72d14948848159ed01ab7af90a090~tplv-k3u1fbpfcp-zoom-1.image)\n简单来说就是“我得知道这些变量在哪里，不然我怎么取到它们再进行下一步操作呀！”\n***\nJavaScript的编译发生代码执行前的几微妙内，并不是发生在构建之前。\n引擎根据作用域进行变量查询，存在两种影响结果的查找方式——LHS/RHS。\nRHS（谁是源头【获取变量的值】）：需要找到这个变量的值才可以进行下一步操作。如console.log(a)，即得到a的值后执行操作。查询操作失败报ReferenceError异常，不合理操作报TypeError异常。\nLHS（目标是谁【对变量赋值】）：为操作找到一个容器，如var a = 2，即找到一个a，给它赋值为2。查询操作失败在非严格模式下会创建变量。*这个特性可以解释变量提升这个东西，也就是“赋值可以跑到声明前”。为了完成赋值这个动作，我可以自己声明一下嘛。现在可以暂时放一下这句话，等到提升时再想。*\n> ~~不推荐使用with/eval~~\n# 二、函数作用域和块作用域\n> 函数作用域含义：属于这个函数的全部变量都可以在整个函数的范围内使用或复用。\nfunction 开头的就是函数声明，其余则是函数表达式。 **正常函数声明被绑定在作用域中，函数表达式则绑定在函数自身中。** 这句话不理解可以先埋下一个伏笔，等下面看到闭包的时候再回头看会回味无穷。\n```\n// 函数声明\nfunction foo(){\nvar a = 2;\nconsole.log(a);\n}\nfoo()\n// 函数表达式\n(function foo(){\nvar a = 2;\nconsole.log(a);\n})()\nvar a = 2;\n(function IIFE(global){\nvar a = 3;\nconsole.log(a, global.a)// 3,2\n})(window)\n// 函数表达式\nvar foo = function(){\nconsole.log(1)\n}\n```\n那么怎么搞出一个块作用域呢？块作用域的声明方式有：\n1.  with 仅在with声明中有效\n1.  try/catch catch内的变量仅在catch内使用\n1.  let 劫持所在块的作用域\n1.  const 与let类似，变量不可修改\n块作用域的优势：1. 有利于垃圾回收（块作用域内代码执行后可以直接回收）；2. 解决 var 循环问题。\n# 三、提升\n> 没有赋值只有声明的变量是会报错 undefined，提升也只是提升了个声明而已；再换句话说，赋值可以跑在声明的前面。光说不干假把式~\n第一段代码可以顺利执行，因为对于 a 的声明会提升到最顶部，因此在作用域内能够找到a。但是这第二段代码中，`var a = 2;`会被拆分为两步，第一步是声明 a ，然后就执行了输出语句，还没有进行赋值呢，因此会出现报错。 这个例子恰好说明了“赋值可以跑在声明前面”。\n***\n例二：\n```\nfoo()\nfunction foo(){\nconsole.log(a); //undefined\nvar a;\n}\n```\n这里也是和例一一样，a会提升声明（作用域在foo内），但是只有声明，没有赋值，所以仍然会报错。\n***\n同样是声明提升，***函数的优先级高于变量***。这里的例子我们可以把函数表达式当作是一个变量的声明，相当于给foo2 这个变量赋值了一个函数。那么由于函数的优先级更高，这个foo2无法覆盖之前的foo1，所以输出仍然是1。\n# 四、闭包\n## 1. 闭包是什么\n首先我们得知道闭包是什么，来看看书里是怎么说的：\n> 函数在 定义时的词法作用域以外的地方 被调用，闭包使得函数可以继续访问定义时的词法作用域。\n这句话的形容使闭包看起来像一种_访问作用域的方法_。我们继续看下一句：\n> 无论通过何种手段将内部函数传递到所在的词法作用域以外，它都会持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包。\n**因此，不应该把比较理解成一种现象或者原理，应该作为一种工具方便我们使用来解决 JavaScript 中的一些问题。这是一个重要的理解点。** 用自己的话再来说一下闭包是什么吧：\n一个函数（A）引用着另一个函数的变量（B），即使 B 已经顺利执行结束了也不会被回收，因为 A 还引用着呢，所以 B 的各种变量也要被保存。\n'
      },{
        id: 30,
        name: 'ZEROL',
        day: '22',
        category: 'JavaScript',
        title: 'setTimeout 和 setInterval，你们两位同学注意点时间~ ',
        intro: '你们两位同学注意点时间~',
        imgsrc: require('../assets/image/ArticleImg2.webp'),
        content:
        '## 一、基本定义与用法 \n### 1、定义\n-   `setTimeout()`方法用于在指定的时间（单位毫秒）后执行回调函数或指定的一段代码\n-   `setInterval()`方法可按照指定的时间间隔（单位毫秒）来调用回调函数或指定的一段代码\n### 2、参数\n-   第一个参数 function，必填，回调函数。或者是一段字符串代码，但是这种方式不建议使用，就和使用`eval()`一样，有安全风险；而且还有作用域问题（字符串会在全局作用域内被解释执行）\n```\nsetTimeout(\'console.log(123);fn()\', 2000)\n```\n-   第二个参数 delay，可选，单位是 ms，对于`setTimeout`是延迟时间，对于`setInterval`是间隔时间，默认都是 0\n-   第三个参数 param1,param2,param3...，可选，是传递给回调函数的参数，不大常用\n ```\nsetTimeout(function (a, b) {\nconsole.log(a, b)\n}, 2000, \'我是\', \'定时器\')\n```\n### 3、返回值\n-   返回一个 ID（数字），可以将这个 ID 传递给`clearTimeout()`或`clearInterval()`来取消执行\n-   PS: `setTimeout()`和`setInterval()`共用一个编号池，技术上，`clearTimeout()`和`clearInterval()`可以互换使用，但是为了避免混淆，一般不这么做\n## 二、setTimeout 和 setInterval 的实际表现\n### 1、使用 setInterval 实现计时\n```\nconst startTime = new Date().getTime()\nlet count = 0\nconst interval = setInterval(function () {\ncount++\nconsole.log(new Date().getTime() - (startTime + count * 1000) + \'ms\')\nif(count === 10){\nclearInterval(interval);\n}\n}, 1000)\n```\n`new Date().getTime() - (startTime + count * 1000)`理想情况下应该是 0ms，然而事实并不是这样，而是存在着误差：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba8397cf6a184ed6a32b285693cff3c0~tplv-k3u1fbpfcp-zoom-1.image)\n### 2、使用 setTimeout 实现计时\n```\nconst startTime = new Date().getTime(), delay = 1000\nlet count = 0\nlet timer = setTimeout(doFunc, delay)\nfunction doFunc(){\ncount++\nconsole.log(new Date().getTime() - (startTime + count * 1000) + \'ms\')\nif(count < 10){\ntimer = setTimeout(doFunc, delay)\n}\n}\n```\nsetTimeout 也同样存在着误差，而且时间越来越大（setTimeout 需要在同步代码执行完成后才重新开始计时）：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c59850b3ac2a475eb718b5492630d88e~tplv-k3u1fbpfcp-zoom-1.image)\n## 三、为什么会出现误差\n### 1、setTimeout 的最短延迟时间\n`setTimeout`遵循的规范由 whatwg 来维护，在 [HTML Standard - 8.6 Timers](https://link.juejin.cn?target=https%3A%2F%2Fhtml.spec.whatwg.org%2Fmultipage%2Ftimers-and-user-prompts.html%23dom-settimeout "https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-settimeout") 中写到了定义定时器的详细步骤，其中有两条：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ffbfbab446fe494fb44c54181f48aa31~tplv-k3u1fbpfcp-zoom-1.image)\n上面的意思就是说，如果设置的 timeout 小于 0，则设置为 0，如果嵌套的层级超过了 5 层（计时器嵌套），并且 timeout 小于 4ms，则设置 timeout 为 4ms。并且，在不同浏览器中出现这种最小延迟的情况有所不同\n具体的源代码实现以及各大浏览器实现的不同，大家可以参考这篇文章：[为什么 setTimeout 有最小延时 4ms ？](https://link.juejin.cn?target=https%3A%2F%2Fwww.bruceyj.com%2Ffront-end-interview-summary%2Fsystem-design%2Fwhy-is-the-design%2F2-why-setTimeout-4ms.html "https://www.bruceyj.com/front-end-interview-summary/system-design/why-is-the-design/2-why-setTimeout-4ms.html")\n这里只看结论，定时器本身的定义步骤是造成其出现误差的原因之一\n### 2、setInterval 的最小间隔时间以及回调函数阻塞\n在 HTML5 标准中，setInterval 的最小间隔为 10ms，虽然我在规范文档中并未找到其相关说明，但是经过实际测试，也确实存在最小间隔时间，例如以下代码：\n```\nlet startTime = new Date().getTime()\nlet count = 0\nconst interval = setInterval(function () {\ncount++\n console.log(new Date().getTime() - startTime + \'ms\')\nstartTime = new Date().getTime()\nif(count === 10) {\nclearInterval(interval)\n}\n}, 0)\n```\n测试结果：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9bcffa807d384a7ab542fd1174186b12~tplv-k3u1fbpfcp-zoom-1.image)\n虽然没有 10ms 那么大的间隔，但是间隔仍然存在，猜测具体的间隔时间是和浏览器实现以及设备性能有关，无论如何，间隔是确实存在的\n另外，当使用 setInterval 时间间隔到点后，仅当队列中没有该定时器的任何其他代码实例时，才会将定时器的代码添加到队列中，如果有的话，则不会添加，造成堵塞，这个也与 JS 的事件循环有关\n### 3、未被激活的tabs的定时最小延迟 >= 1000ms\n为了优化后台 tab 的加载损耗（以及降低耗电量），在未被激活的 tab 中定时器的最小延时限制为1s(1000ms)，具体时间在不同的浏览器实现中也有差别\n### 4、JS 的事件循环机制\n`setTimeout`和`setInterval`中的时间并不是到点就立即执行，而是到点将其回调函数加入异步事件队列中，按照队列先进先出的性质，该回调函数到点之后是否能执行还得取决于是否属于队列首位，如果前头还有其他事件在等待，则不能按点执行，如果没有，则将其放入同步队列执行。具体事件循环机制，可以参考这篇文章：[动图学习-EventLoop](https://juejin.cn/post/6969028296893792286 "https://juejin.cn/post/6969028296893792286")\n## 四、解决方案\n### 1、在浏览器中实现一个 0ms 延时的定时器\n可以参考如下代码（来自于国外的一篇博客，也是 MDN 推荐的方法），主要是使用了 postMessage 方法，异步的执行了回调函数，并且速度要比 setTimeout(0) 要快的多。具体比较可以参照原文：[setTimeout with a shorter delay](https://link.juejin.cn?target=https%3A%2F%2Fdbaron.org%2Flog%2F20100309-faster-timeouts "https://dbaron.org/log/20100309-faster-timeouts")\n使用 setTimeout(0) 得到的时间：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8994a7da32e549cd9d06c34d1ac0bbc8~tplv-k3u1fbpfcp-zoom-1.image)\n将 setTimeout 改成 setZeroTimeout 后得到的时间，时间几乎都在 0～1，至于为什么不是绝对的 0，猜测可能与性能有关，总的来说，时间确实缩短了：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dced5471b7fc422d9f9eb28259b26ce2~tplv-k3u1fbpfcp-zoom-1.image)\n### 2、购物网站的秒杀活动\n一般情况下，从服务器拿到倒数时间后，前端的执行倒计时程序持续运行，事实上，显示时间相比实际时间会越来越慢的\n究其原因，倒计时通常是使用定时器实现，而 JS 的单线程特性使得同步任务执行过程中出现阻塞时，任务队列中的异步任务并不能及时执行，因此浏览器并不能保证在定时器设置的时间结束后代码总是被准时执行，从而造成了倒计时的偏差\n一般的解决方法是前端定时向服务器发送请求获取最新的时间差来校准倒计时时间，和用户一直按 F5 刷新没啥区别，比较简单粗暴，下面的方法可以一定程度上解决这个问题，纯前端控制，不依赖于后端。源地址已忘\n## 五、使用 setTimeout 替代 setInterval\n定时器指定的时间间隔，表示的是何时将定时器的代码添加到消息队列，而不是何时执行代码。所以真正何时执行代码的时间是不能保证的，它取决于何时被主线程的事件循环获取到，并执行\n假设有 `setInterval(function, 100)`，它的执行可能是这样的：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/30346ef998214cabb6c95141b19ad25f~tplv-k3u1fbpfcp-zoom-1.image)\n上图可见，setInterval 每隔 100ms 往队列中添加一个事件；100ms 后，添加 T1 定时器代码至队列中，主线程中还有任务在执行，所以等待，some event 执行结束后执行 T1 定时器代码；又过了100ms，T2定时器被添加到队列中，主线程还在执行 T1 代码，所以等待；又过了 100ms，理论上又要往队列里推一个定时器代码，但由于此时 T2 还在队列中，所以 T3 不会被添加，结果就是此时被跳过；然后，T1 定时器执行结束后马上执行了 T2 代码，所以并没有达到定时器间隔的效果\n综上所述，serInterval 有两个问题：\n-   可能多个定时器会连续执行（会导致后续的间隔误差）\n-   某些间隔会被跳过（这么设计也可能是为了尽量避免第一个问题）\n因而一般会使用 setTimeout 模拟 setInterval，来规避掉上面的缺点\n```\nsetTimeout(function fn() {\n// do something\nsetTimeout(fn, delay)\n}, delay)\n```\n这样的话，在前一个定时器代码执行完成前，不会向队列中插入新的定时器（不会连续执行），而且保证了定时器间隔\n注：有些说法，可能对当队列中存在定时器实例时，是否会跳过添加实例，存在质疑；还有的说法是，在 Node 环境中会跳过，在浏览器环境中会累加；不过我这边实测，不管在 Node 还是在 web 中，当队列中存在定时器实例时，都会跳过添加的；当然也有可能是浏览器版本或内核不同，表现不同，没有细测；感兴趣的小伙伴可以使用一下代码实测下，看是会一次性输出，还是会间隔性输出\n**这边顺便一提，涉及到做动画的场景可能会使用定时器**\n-   由于定时器的种种误差问题，以及固定时间间隔不一定与屏幕刷新时间相同，可能会引起丢帧；而且定时器在后台仍会继续执行，也会造成资源的浪费\n-   一般情况下，还是推荐使用 requestAnimationFrame，RAF 重绘或回流（重排）的时间间隔是紧紧跟随浏览器的刷新频率的；并且在页面未激活时，该页面的屏幕刷新任务也会被暂停，当页面被激活时，任务会从上次停留的地方继续执行，这也就意味着将耗费更少的资源，提升了性能\n### 总结\n-   setTimeout 和 setInterval 都存在计时误差，不会严格按照既定时间执行\n-   一般情况下，这些误差不会造成太大影响，只对于某些特殊场景，对时间要求比较严格的情况下，需要特殊处理\n-   对于 setInterval，个人建议能不用尽量不用，使用 setTimeout 的嵌套实现，可以规避掉一些潜在问题的发生\n'
      },{
        id: 31,
        name: '望舟',
        day: '1',
        category: '面试',
        title: '让“作用域和闭包”说人话！ ',
        intro: '让作用域和闭包说人话，面试时候有话可讲！',
        imgsrc: require('../assets/image/ArticleImg1.webp'),
        content:
        '# 一、作用域是什么\n作用域与编译原理息息相关，但是我们暂时还不用管编译原理的复杂过程，它的作用可以简单看下面这张图： \n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2dc72d14948848159ed01ab7af90a090~tplv-k3u1fbpfcp-zoom-1.image)\n简单来说就是“我得知道这些变量在哪里，不然我怎么取到它们再进行下一步操作呀！”\n***\nJavaScript的编译发生代码执行前的几微妙内，并不是发生在构建之前。\n引擎根据作用域进行变量查询，存在两种影响结果的查找方式——LHS/RHS。\nRHS（谁是源头【获取变量的值】）：需要找到这个变量的值才可以进行下一步操作。如console.log(a)，即得到a的值后执行操作。查询操作失败报ReferenceError异常，不合理操作报TypeError异常。\nLHS（目标是谁【对变量赋值】）：为操作找到一个容器，如var a = 2，即找到一个a，给它赋值为2。查询操作失败在非严格模式下会创建变量。*这个特性可以解释变量提升这个东西，也就是“赋值可以跑到声明前”。为了完成赋值这个动作，我可以自己声明一下嘛。现在可以暂时放一下这句话，等到提升时再想。*\n> ~~不推荐使用with/eval~~\n# 二、函数作用域和块作用域\n> 函数作用域含义：属于这个函数的全部变量都可以在整个函数的范围内使用或复用。\nfunction 开头的就是函数声明，其余则是函数表达式。 **正常函数声明被绑定在作用域中，函数表达式则绑定在函数自身中。** 这句话不理解可以先埋下一个伏笔，等下面看到闭包的时候再回头看会回味无穷。\n```\n// 函数声明\nfunction foo(){\nvar a = 2;\nconsole.log(a);\n}\nfoo()\n// 函数表达式\n(function foo(){\nvar a = 2;\nconsole.log(a);\n})()\nvar a = 2;\n(function IIFE(global){\nvar a = 3;\nconsole.log(a, global.a)// 3,2\n})(window)\n// 函数表达式\nvar foo = function(){\nconsole.log(1)\n}\n```\n那么怎么搞出一个块作用域呢？块作用域的声明方式有：\n1.  with 仅在with声明中有效\n1.  try/catch catch内的变量仅在catch内使用\n1.  let 劫持所在块的作用域\n1.  const 与let类似，变量不可修改\n块作用域的优势：1. 有利于垃圾回收（块作用域内代码执行后可以直接回收）；2. 解决 var 循环问题。\n# 三、提升\n> 没有赋值只有声明的变量是会报错 undefined，提升也只是提升了个声明而已；再换句话说，赋值可以跑在声明的前面。光说不干假把式~\n第一段代码可以顺利执行，因为对于 a 的声明会提升到最顶部，因此在作用域内能够找到a。但是这第二段代码中，`var a = 2;`会被拆分为两步，第一步是声明 a ，然后就执行了输出语句，还没有进行赋值呢，因此会出现报错。 这个例子恰好说明了“赋值可以跑在声明前面”。\n***\n例二：\n```\nfoo()\nfunction foo(){\nconsole.log(a); //undefined\nvar a;\n}\n```\n这里也是和例一一样，a会提升声明（作用域在foo内），但是只有声明，没有赋值，所以仍然会报错。\n***\n同样是声明提升，***函数的优先级高于变量***。这里的例子我们可以把函数表达式当作是一个变量的声明，相当于给foo2 这个变量赋值了一个函数。那么由于函数的优先级更高，这个foo2无法覆盖之前的foo1，所以输出仍然是1。\n# 四、闭包\n## 1. 闭包是什么\n首先我们得知道闭包是什么，来看看书里是怎么说的：\n> 函数在 定义时的词法作用域以外的地方 被调用，闭包使得函数可以继续访问定义时的词法作用域。\n这句话的形容使闭包看起来像一种_访问作用域的方法_。我们继续看下一句：\n> 无论通过何种手段将内部函数传递到所在的词法作用域以外，它都会持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包。\n**因此，不应该把比较理解成一种现象或者原理，应该作为一种工具方便我们使用来解决 JavaScript 中的一些问题。这是一个重要的理解点。** 用自己的话再来说一下闭包是什么吧：\n一个函数（A）引用着另一个函数的变量（B），即使 B 已经顺利执行结束了也不会被回收，因为 A 还引用着呢，所以 B 的各种变量也要被保存。\n'
      },{
        id: 32,
        name: 'ZEROL',
        day: '22',
        category: 'JavaScript',
        title: 'setTimeout 和 setInterval，你们两位同学注意点时间~ ',
        intro: '你们两位同学注意点时间~',
        imgsrc: require('../assets/image/ArticleImg2.webp'),
        content:
        '## 一、基本定义与用法 \n### 1、定义\n-   `setTimeout()`方法用于在指定的时间（单位毫秒）后执行回调函数或指定的一段代码\n-   `setInterval()`方法可按照指定的时间间隔（单位毫秒）来调用回调函数或指定的一段代码\n### 2、参数\n-   第一个参数 function，必填，回调函数。或者是一段字符串代码，但是这种方式不建议使用，就和使用`eval()`一样，有安全风险；而且还有作用域问题（字符串会在全局作用域内被解释执行）\n```\nsetTimeout(\'console.log(123);fn()\', 2000)\n```\n-   第二个参数 delay，可选，单位是 ms，对于`setTimeout`是延迟时间，对于`setInterval`是间隔时间，默认都是 0\n-   第三个参数 param1,param2,param3...，可选，是传递给回调函数的参数，不大常用\n ```\nsetTimeout(function (a, b) {\nconsole.log(a, b)\n}, 2000, \'我是\', \'定时器\')\n```\n### 3、返回值\n-   返回一个 ID（数字），可以将这个 ID 传递给`clearTimeout()`或`clearInterval()`来取消执行\n-   PS: `setTimeout()`和`setInterval()`共用一个编号池，技术上，`clearTimeout()`和`clearInterval()`可以互换使用，但是为了避免混淆，一般不这么做\n## 二、setTimeout 和 setInterval 的实际表现\n### 1、使用 setInterval 实现计时\n```\nconst startTime = new Date().getTime()\nlet count = 0\nconst interval = setInterval(function () {\ncount++\nconsole.log(new Date().getTime() - (startTime + count * 1000) + \'ms\')\nif(count === 10){\nclearInterval(interval);\n}\n}, 1000)\n```\n`new Date().getTime() - (startTime + count * 1000)`理想情况下应该是 0ms，然而事实并不是这样，而是存在着误差：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba8397cf6a184ed6a32b285693cff3c0~tplv-k3u1fbpfcp-zoom-1.image)\n### 2、使用 setTimeout 实现计时\n```\nconst startTime = new Date().getTime(), delay = 1000\nlet count = 0\nlet timer = setTimeout(doFunc, delay)\nfunction doFunc(){\ncount++\nconsole.log(new Date().getTime() - (startTime + count * 1000) + \'ms\')\nif(count < 10){\ntimer = setTimeout(doFunc, delay)\n}\n}\n```\nsetTimeout 也同样存在着误差，而且时间越来越大（setTimeout 需要在同步代码执行完成后才重新开始计时）：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c59850b3ac2a475eb718b5492630d88e~tplv-k3u1fbpfcp-zoom-1.image)\n## 三、为什么会出现误差\n### 1、setTimeout 的最短延迟时间\n`setTimeout`遵循的规范由 whatwg 来维护，在 [HTML Standard - 8.6 Timers](https://link.juejin.cn?target=https%3A%2F%2Fhtml.spec.whatwg.org%2Fmultipage%2Ftimers-and-user-prompts.html%23dom-settimeout "https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-settimeout") 中写到了定义定时器的详细步骤，其中有两条：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ffbfbab446fe494fb44c54181f48aa31~tplv-k3u1fbpfcp-zoom-1.image)\n上面的意思就是说，如果设置的 timeout 小于 0，则设置为 0，如果嵌套的层级超过了 5 层（计时器嵌套），并且 timeout 小于 4ms，则设置 timeout 为 4ms。并且，在不同浏览器中出现这种最小延迟的情况有所不同\n具体的源代码实现以及各大浏览器实现的不同，大家可以参考这篇文章：[为什么 setTimeout 有最小延时 4ms ？](https://link.juejin.cn?target=https%3A%2F%2Fwww.bruceyj.com%2Ffront-end-interview-summary%2Fsystem-design%2Fwhy-is-the-design%2F2-why-setTimeout-4ms.html "https://www.bruceyj.com/front-end-interview-summary/system-design/why-is-the-design/2-why-setTimeout-4ms.html")\n这里只看结论，定时器本身的定义步骤是造成其出现误差的原因之一\n### 2、setInterval 的最小间隔时间以及回调函数阻塞\n在 HTML5 标准中，setInterval 的最小间隔为 10ms，虽然我在规范文档中并未找到其相关说明，但是经过实际测试，也确实存在最小间隔时间，例如以下代码：\n```\nlet startTime = new Date().getTime()\nlet count = 0\nconst interval = setInterval(function () {\ncount++\n console.log(new Date().getTime() - startTime + \'ms\')\nstartTime = new Date().getTime()\nif(count === 10) {\nclearInterval(interval)\n}\n}, 0)\n```\n测试结果：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9bcffa807d384a7ab542fd1174186b12~tplv-k3u1fbpfcp-zoom-1.image)\n虽然没有 10ms 那么大的间隔，但是间隔仍然存在，猜测具体的间隔时间是和浏览器实现以及设备性能有关，无论如何，间隔是确实存在的\n另外，当使用 setInterval 时间间隔到点后，仅当队列中没有该定时器的任何其他代码实例时，才会将定时器的代码添加到队列中，如果有的话，则不会添加，造成堵塞，这个也与 JS 的事件循环有关\n### 3、未被激活的tabs的定时最小延迟 >= 1000ms\n为了优化后台 tab 的加载损耗（以及降低耗电量），在未被激活的 tab 中定时器的最小延时限制为1s(1000ms)，具体时间在不同的浏览器实现中也有差别\n### 4、JS 的事件循环机制\n`setTimeout`和`setInterval`中的时间并不是到点就立即执行，而是到点将其回调函数加入异步事件队列中，按照队列先进先出的性质，该回调函数到点之后是否能执行还得取决于是否属于队列首位，如果前头还有其他事件在等待，则不能按点执行，如果没有，则将其放入同步队列执行。具体事件循环机制，可以参考这篇文章：[动图学习-EventLoop](https://juejin.cn/post/6969028296893792286 "https://juejin.cn/post/6969028296893792286")\n## 四、解决方案\n### 1、在浏览器中实现一个 0ms 延时的定时器\n可以参考如下代码（来自于国外的一篇博客，也是 MDN 推荐的方法），主要是使用了 postMessage 方法，异步的执行了回调函数，并且速度要比 setTimeout(0) 要快的多。具体比较可以参照原文：[setTimeout with a shorter delay](https://link.juejin.cn?target=https%3A%2F%2Fdbaron.org%2Flog%2F20100309-faster-timeouts "https://dbaron.org/log/20100309-faster-timeouts")\n使用 setTimeout(0) 得到的时间：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8994a7da32e549cd9d06c34d1ac0bbc8~tplv-k3u1fbpfcp-zoom-1.image)\n将 setTimeout 改成 setZeroTimeout 后得到的时间，时间几乎都在 0～1，至于为什么不是绝对的 0，猜测可能与性能有关，总的来说，时间确实缩短了：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dced5471b7fc422d9f9eb28259b26ce2~tplv-k3u1fbpfcp-zoom-1.image)\n### 2、购物网站的秒杀活动\n一般情况下，从服务器拿到倒数时间后，前端的执行倒计时程序持续运行，事实上，显示时间相比实际时间会越来越慢的\n究其原因，倒计时通常是使用定时器实现，而 JS 的单线程特性使得同步任务执行过程中出现阻塞时，任务队列中的异步任务并不能及时执行，因此浏览器并不能保证在定时器设置的时间结束后代码总是被准时执行，从而造成了倒计时的偏差\n一般的解决方法是前端定时向服务器发送请求获取最新的时间差来校准倒计时时间，和用户一直按 F5 刷新没啥区别，比较简单粗暴，下面的方法可以一定程度上解决这个问题，纯前端控制，不依赖于后端。源地址已忘\n## 五、使用 setTimeout 替代 setInterval\n定时器指定的时间间隔，表示的是何时将定时器的代码添加到消息队列，而不是何时执行代码。所以真正何时执行代码的时间是不能保证的，它取决于何时被主线程的事件循环获取到，并执行\n假设有 `setInterval(function, 100)`，它的执行可能是这样的：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/30346ef998214cabb6c95141b19ad25f~tplv-k3u1fbpfcp-zoom-1.image)\n上图可见，setInterval 每隔 100ms 往队列中添加一个事件；100ms 后，添加 T1 定时器代码至队列中，主线程中还有任务在执行，所以等待，some event 执行结束后执行 T1 定时器代码；又过了100ms，T2定时器被添加到队列中，主线程还在执行 T1 代码，所以等待；又过了 100ms，理论上又要往队列里推一个定时器代码，但由于此时 T2 还在队列中，所以 T3 不会被添加，结果就是此时被跳过；然后，T1 定时器执行结束后马上执行了 T2 代码，所以并没有达到定时器间隔的效果\n综上所述，serInterval 有两个问题：\n-   可能多个定时器会连续执行（会导致后续的间隔误差）\n-   某些间隔会被跳过（这么设计也可能是为了尽量避免第一个问题）\n因而一般会使用 setTimeout 模拟 setInterval，来规避掉上面的缺点\n```\nsetTimeout(function fn() {\n// do something\nsetTimeout(fn, delay)\n}, delay)\n```\n这样的话，在前一个定时器代码执行完成前，不会向队列中插入新的定时器（不会连续执行），而且保证了定时器间隔\n注：有些说法，可能对当队列中存在定时器实例时，是否会跳过添加实例，存在质疑；还有的说法是，在 Node 环境中会跳过，在浏览器环境中会累加；不过我这边实测，不管在 Node 还是在 web 中，当队列中存在定时器实例时，都会跳过添加的；当然也有可能是浏览器版本或内核不同，表现不同，没有细测；感兴趣的小伙伴可以使用一下代码实测下，看是会一次性输出，还是会间隔性输出\n**这边顺便一提，涉及到做动画的场景可能会使用定时器**\n-   由于定时器的种种误差问题，以及固定时间间隔不一定与屏幕刷新时间相同，可能会引起丢帧；而且定时器在后台仍会继续执行，也会造成资源的浪费\n-   一般情况下，还是推荐使用 requestAnimationFrame，RAF 重绘或回流（重排）的时间间隔是紧紧跟随浏览器的刷新频率的；并且在页面未激活时，该页面的屏幕刷新任务也会被暂停，当页面被激活时，任务会从上次停留的地方继续执行，这也就意味着将耗费更少的资源，提升了性能\n### 总结\n-   setTimeout 和 setInterval 都存在计时误差，不会严格按照既定时间执行\n-   一般情况下，这些误差不会造成太大影响，只对于某些特殊场景，对时间要求比较严格的情况下，需要特殊处理\n-   对于 setInterval，个人建议能不用尽量不用，使用 setTimeout 的嵌套实现，可以规避掉一些潜在问题的发生\n'
      },{
        id: 33,
        name: 'ZEROL',
        day: '22',
        category: 'JavaScript',
        title: 'setTimeout 和 setInterval，你们两位同学注意点时间~ ',
        intro: '你们两位同学注意点时间~',
        imgsrc: require('../assets/image/ArticleImg2.webp'),
        content:
        '## 一、基本定义与用法 \n### 1、定义\n-   `setTimeout()`方法用于在指定的时间（单位毫秒）后执行回调函数或指定的一段代码\n-   `setInterval()`方法可按照指定的时间间隔（单位毫秒）来调用回调函数或指定的一段代码\n### 2、参数\n-   第一个参数 function，必填，回调函数。或者是一段字符串代码，但是这种方式不建议使用，就和使用`eval()`一样，有安全风险；而且还有作用域问题（字符串会在全局作用域内被解释执行）\n```\nsetTimeout(\'console.log(123);fn()\', 2000)\n```\n-   第二个参数 delay，可选，单位是 ms，对于`setTimeout`是延迟时间，对于`setInterval`是间隔时间，默认都是 0\n-   第三个参数 param1,param2,param3...，可选，是传递给回调函数的参数，不大常用\n ```\nsetTimeout(function (a, b) {\nconsole.log(a, b)\n}, 2000, \'我是\', \'定时器\')\n```\n### 3、返回值\n-   返回一个 ID（数字），可以将这个 ID 传递给`clearTimeout()`或`clearInterval()`来取消执行\n-   PS: `setTimeout()`和`setInterval()`共用一个编号池，技术上，`clearTimeout()`和`clearInterval()`可以互换使用，但是为了避免混淆，一般不这么做\n## 二、setTimeout 和 setInterval 的实际表现\n### 1、使用 setInterval 实现计时\n```\nconst startTime = new Date().getTime()\nlet count = 0\nconst interval = setInterval(function () {\ncount++\nconsole.log(new Date().getTime() - (startTime + count * 1000) + \'ms\')\nif(count === 10){\nclearInterval(interval);\n}\n}, 1000)\n```\n`new Date().getTime() - (startTime + count * 1000)`理想情况下应该是 0ms，然而事实并不是这样，而是存在着误差：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba8397cf6a184ed6a32b285693cff3c0~tplv-k3u1fbpfcp-zoom-1.image)\n### 2、使用 setTimeout 实现计时\n```\nconst startTime = new Date().getTime(), delay = 1000\nlet count = 0\nlet timer = setTimeout(doFunc, delay)\nfunction doFunc(){\ncount++\nconsole.log(new Date().getTime() - (startTime + count * 1000) + \'ms\')\nif(count < 10){\ntimer = setTimeout(doFunc, delay)\n}\n}\n```\nsetTimeout 也同样存在着误差，而且时间越来越大（setTimeout 需要在同步代码执行完成后才重新开始计时）：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c59850b3ac2a475eb718b5492630d88e~tplv-k3u1fbpfcp-zoom-1.image)\n## 三、为什么会出现误差\n### 1、setTimeout 的最短延迟时间\n`setTimeout`遵循的规范由 whatwg 来维护，在 [HTML Standard - 8.6 Timers](https://link.juejin.cn?target=https%3A%2F%2Fhtml.spec.whatwg.org%2Fmultipage%2Ftimers-and-user-prompts.html%23dom-settimeout "https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-settimeout") 中写到了定义定时器的详细步骤，其中有两条：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ffbfbab446fe494fb44c54181f48aa31~tplv-k3u1fbpfcp-zoom-1.image)\n上面的意思就是说，如果设置的 timeout 小于 0，则设置为 0，如果嵌套的层级超过了 5 层（计时器嵌套），并且 timeout 小于 4ms，则设置 timeout 为 4ms。并且，在不同浏览器中出现这种最小延迟的情况有所不同\n具体的源代码实现以及各大浏览器实现的不同，大家可以参考这篇文章：[为什么 setTimeout 有最小延时 4ms ？](https://link.juejin.cn?target=https%3A%2F%2Fwww.bruceyj.com%2Ffront-end-interview-summary%2Fsystem-design%2Fwhy-is-the-design%2F2-why-setTimeout-4ms.html "https://www.bruceyj.com/front-end-interview-summary/system-design/why-is-the-design/2-why-setTimeout-4ms.html")\n这里只看结论，定时器本身的定义步骤是造成其出现误差的原因之一\n### 2、setInterval 的最小间隔时间以及回调函数阻塞\n在 HTML5 标准中，setInterval 的最小间隔为 10ms，虽然我在规范文档中并未找到其相关说明，但是经过实际测试，也确实存在最小间隔时间，例如以下代码：\n```\nlet startTime = new Date().getTime()\nlet count = 0\nconst interval = setInterval(function () {\ncount++\n console.log(new Date().getTime() - startTime + \'ms\')\nstartTime = new Date().getTime()\nif(count === 10) {\nclearInterval(interval)\n}\n}, 0)\n```\n测试结果：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9bcffa807d384a7ab542fd1174186b12~tplv-k3u1fbpfcp-zoom-1.image)\n虽然没有 10ms 那么大的间隔，但是间隔仍然存在，猜测具体的间隔时间是和浏览器实现以及设备性能有关，无论如何，间隔是确实存在的\n另外，当使用 setInterval 时间间隔到点后，仅当队列中没有该定时器的任何其他代码实例时，才会将定时器的代码添加到队列中，如果有的话，则不会添加，造成堵塞，这个也与 JS 的事件循环有关\n### 3、未被激活的tabs的定时最小延迟 >= 1000ms\n为了优化后台 tab 的加载损耗（以及降低耗电量），在未被激活的 tab 中定时器的最小延时限制为1s(1000ms)，具体时间在不同的浏览器实现中也有差别\n### 4、JS 的事件循环机制\n`setTimeout`和`setInterval`中的时间并不是到点就立即执行，而是到点将其回调函数加入异步事件队列中，按照队列先进先出的性质，该回调函数到点之后是否能执行还得取决于是否属于队列首位，如果前头还有其他事件在等待，则不能按点执行，如果没有，则将其放入同步队列执行。具体事件循环机制，可以参考这篇文章：[动图学习-EventLoop](https://juejin.cn/post/6969028296893792286 "https://juejin.cn/post/6969028296893792286")\n## 四、解决方案\n### 1、在浏览器中实现一个 0ms 延时的定时器\n可以参考如下代码（来自于国外的一篇博客，也是 MDN 推荐的方法），主要是使用了 postMessage 方法，异步的执行了回调函数，并且速度要比 setTimeout(0) 要快的多。具体比较可以参照原文：[setTimeout with a shorter delay](https://link.juejin.cn?target=https%3A%2F%2Fdbaron.org%2Flog%2F20100309-faster-timeouts "https://dbaron.org/log/20100309-faster-timeouts")\n使用 setTimeout(0) 得到的时间：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8994a7da32e549cd9d06c34d1ac0bbc8~tplv-k3u1fbpfcp-zoom-1.image)\n将 setTimeout 改成 setZeroTimeout 后得到的时间，时间几乎都在 0～1，至于为什么不是绝对的 0，猜测可能与性能有关，总的来说，时间确实缩短了：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dced5471b7fc422d9f9eb28259b26ce2~tplv-k3u1fbpfcp-zoom-1.image)\n### 2、购物网站的秒杀活动\n一般情况下，从服务器拿到倒数时间后，前端的执行倒计时程序持续运行，事实上，显示时间相比实际时间会越来越慢的\n究其原因，倒计时通常是使用定时器实现，而 JS 的单线程特性使得同步任务执行过程中出现阻塞时，任务队列中的异步任务并不能及时执行，因此浏览器并不能保证在定时器设置的时间结束后代码总是被准时执行，从而造成了倒计时的偏差\n一般的解决方法是前端定时向服务器发送请求获取最新的时间差来校准倒计时时间，和用户一直按 F5 刷新没啥区别，比较简单粗暴，下面的方法可以一定程度上解决这个问题，纯前端控制，不依赖于后端。源地址已忘\n## 五、使用 setTimeout 替代 setInterval\n定时器指定的时间间隔，表示的是何时将定时器的代码添加到消息队列，而不是何时执行代码。所以真正何时执行代码的时间是不能保证的，它取决于何时被主线程的事件循环获取到，并执行\n假设有 `setInterval(function, 100)`，它的执行可能是这样的：\n![png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/30346ef998214cabb6c95141b19ad25f~tplv-k3u1fbpfcp-zoom-1.image)\n上图可见，setInterval 每隔 100ms 往队列中添加一个事件；100ms 后，添加 T1 定时器代码至队列中，主线程中还有任务在执行，所以等待，some event 执行结束后执行 T1 定时器代码；又过了100ms，T2定时器被添加到队列中，主线程还在执行 T1 代码，所以等待；又过了 100ms，理论上又要往队列里推一个定时器代码，但由于此时 T2 还在队列中，所以 T3 不会被添加，结果就是此时被跳过；然后，T1 定时器执行结束后马上执行了 T2 代码，所以并没有达到定时器间隔的效果\n综上所述，serInterval 有两个问题：\n-   可能多个定时器会连续执行（会导致后续的间隔误差）\n-   某些间隔会被跳过（这么设计也可能是为了尽量避免第一个问题）\n因而一般会使用 setTimeout 模拟 setInterval，来规避掉上面的缺点\n```\nsetTimeout(function fn() {\n// do something\nsetTimeout(fn, delay)\n}, delay)\n```\n这样的话，在前一个定时器代码执行完成前，不会向队列中插入新的定时器（不会连续执行），而且保证了定时器间隔\n注：有些说法，可能对当队列中存在定时器实例时，是否会跳过添加实例，存在质疑；还有的说法是，在 Node 环境中会跳过，在浏览器环境中会累加；不过我这边实测，不管在 Node 还是在 web 中，当队列中存在定时器实例时，都会跳过添加的；当然也有可能是浏览器版本或内核不同，表现不同，没有细测；感兴趣的小伙伴可以使用一下代码实测下，看是会一次性输出，还是会间隔性输出\n**这边顺便一提，涉及到做动画的场景可能会使用定时器**\n-   由于定时器的种种误差问题，以及固定时间间隔不一定与屏幕刷新时间相同，可能会引起丢帧；而且定时器在后台仍会继续执行，也会造成资源的浪费\n-   一般情况下，还是推荐使用 requestAnimationFrame，RAF 重绘或回流（重排）的时间间隔是紧紧跟随浏览器的刷新频率的；并且在页面未激活时，该页面的屏幕刷新任务也会被暂停，当页面被激活时，任务会从上次停留的地方继续执行，这也就意味着将耗费更少的资源，提升了性能\n### 总结\n-   setTimeout 和 setInterval 都存在计时误差，不会严格按照既定时间执行\n-   一般情况下，这些误差不会造成太大影响，只对于某些特殊场景，对时间要求比较严格的情况下，需要特殊处理\n-   对于 setInterval，个人建议能不用尽量不用，使用 setTimeout 的嵌套实现，可以规避掉一些潜在问题的发生\n'
      },{
        id: 34,
        name: '望舟',
        day: '1',
        category: '面试',
        title: '让“作用域和闭包”说人话！ ',
        intro: '让作用域和闭包说人话，面试时候有话可讲！',
        imgsrc: require('../assets/image/ArticleImg1.webp'),
        content:
        '# 一、作用域是什么\n作用域与编译原理息息相关，但是我们暂时还不用管编译原理的复杂过程，它的作用可以简单看下面这张图： \n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2dc72d14948848159ed01ab7af90a090~tplv-k3u1fbpfcp-zoom-1.image)\n简单来说就是“我得知道这些变量在哪里，不然我怎么取到它们再进行下一步操作呀！”\n***\nJavaScript的编译发生代码执行前的几微妙内，并不是发生在构建之前。\n引擎根据作用域进行变量查询，存在两种影响结果的查找方式——LHS/RHS。\nRHS（谁是源头【获取变量的值】）：需要找到这个变量的值才可以进行下一步操作。如console.log(a)，即得到a的值后执行操作。查询操作失败报ReferenceError异常，不合理操作报TypeError异常。\nLHS（目标是谁【对变量赋值】）：为操作找到一个容器，如var a = 2，即找到一个a，给它赋值为2。查询操作失败在非严格模式下会创建变量。*这个特性可以解释变量提升这个东西，也就是“赋值可以跑到声明前”。为了完成赋值这个动作，我可以自己声明一下嘛。现在可以暂时放一下这句话，等到提升时再想。*\n> ~~不推荐使用with/eval~~\n# 二、函数作用域和块作用域\n> 函数作用域含义：属于这个函数的全部变量都可以在整个函数的范围内使用或复用。\nfunction 开头的就是函数声明，其余则是函数表达式。 **正常函数声明被绑定在作用域中，函数表达式则绑定在函数自身中。** 这句话不理解可以先埋下一个伏笔，等下面看到闭包的时候再回头看会回味无穷。\n```\n// 函数声明\nfunction foo(){\nvar a = 2;\nconsole.log(a);\n}\nfoo()\n// 函数表达式\n(function foo(){\nvar a = 2;\nconsole.log(a);\n})()\nvar a = 2;\n(function IIFE(global){\nvar a = 3;\nconsole.log(a, global.a)// 3,2\n})(window)\n// 函数表达式\nvar foo = function(){\nconsole.log(1)\n}\n```\n那么怎么搞出一个块作用域呢？块作用域的声明方式有：\n1.  with 仅在with声明中有效\n1.  try/catch catch内的变量仅在catch内使用\n1.  let 劫持所在块的作用域\n1.  const 与let类似，变量不可修改\n块作用域的优势：1. 有利于垃圾回收（块作用域内代码执行后可以直接回收）；2. 解决 var 循环问题。\n# 三、提升\n> 没有赋值只有声明的变量是会报错 undefined，提升也只是提升了个声明而已；再换句话说，赋值可以跑在声明的前面。光说不干假把式~\n第一段代码可以顺利执行，因为对于 a 的声明会提升到最顶部，因此在作用域内能够找到a。但是这第二段代码中，`var a = 2;`会被拆分为两步，第一步是声明 a ，然后就执行了输出语句，还没有进行赋值呢，因此会出现报错。 这个例子恰好说明了“赋值可以跑在声明前面”。\n***\n例二：\n```\nfoo()\nfunction foo(){\nconsole.log(a); //undefined\nvar a;\n}\n```\n这里也是和例一一样，a会提升声明（作用域在foo内），但是只有声明，没有赋值，所以仍然会报错。\n***\n同样是声明提升，***函数的优先级高于变量***。这里的例子我们可以把函数表达式当作是一个变量的声明，相当于给foo2 这个变量赋值了一个函数。那么由于函数的优先级更高，这个foo2无法覆盖之前的foo1，所以输出仍然是1。\n# 四、闭包\n## 1. 闭包是什么\n首先我们得知道闭包是什么，来看看书里是怎么说的：\n> 函数在 定义时的词法作用域以外的地方 被调用，闭包使得函数可以继续访问定义时的词法作用域。\n这句话的形容使闭包看起来像一种_访问作用域的方法_。我们继续看下一句：\n> 无论通过何种手段将内部函数传递到所在的词法作用域以外，它都会持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包。\n**因此，不应该把比较理解成一种现象或者原理，应该作为一种工具方便我们使用来解决 JavaScript 中的一些问题。这是一个重要的理解点。** 用自己的话再来说一下闭包是什么吧：\n一个函数（A）引用着另一个函数的变量（B），即使 B 已经顺利执行结束了也不会被回收，因为 A 还引用着呢，所以 B 的各种变量也要被保存。\n'
      },{
        id: 35,
        name: '望舟',
        day: '1',
        category: '面试',
        title: '让“作用域和闭包”说人话！ ',
        intro: '让作用域和闭包说人话，面试时候有话可讲！',
        imgsrc: require('../assets/image/ArticleImg1.webp'),
        content:
        '# 一、作用域是什么\n作用域与编译原理息息相关，但是我们暂时还不用管编译原理的复杂过程，它的作用可以简单看下面这张图： \n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2dc72d14948848159ed01ab7af90a090~tplv-k3u1fbpfcp-zoom-1.image)\n简单来说就是“我得知道这些变量在哪里，不然我怎么取到它们再进行下一步操作呀！”\n***\nJavaScript的编译发生代码执行前的几微妙内，并不是发生在构建之前。\n引擎根据作用域进行变量查询，存在两种影响结果的查找方式——LHS/RHS。\nRHS（谁是源头【获取变量的值】）：需要找到这个变量的值才可以进行下一步操作。如console.log(a)，即得到a的值后执行操作。查询操作失败报ReferenceError异常，不合理操作报TypeError异常。\nLHS（目标是谁【对变量赋值】）：为操作找到一个容器，如var a = 2，即找到一个a，给它赋值为2。查询操作失败在非严格模式下会创建变量。*这个特性可以解释变量提升这个东西，也就是“赋值可以跑到声明前”。为了完成赋值这个动作，我可以自己声明一下嘛。现在可以暂时放一下这句话，等到提升时再想。*\n> ~~不推荐使用with/eval~~\n# 二、函数作用域和块作用域\n> 函数作用域含义：属于这个函数的全部变量都可以在整个函数的范围内使用或复用。\nfunction 开头的就是函数声明，其余则是函数表达式。 **正常函数声明被绑定在作用域中，函数表达式则绑定在函数自身中。** 这句话不理解可以先埋下一个伏笔，等下面看到闭包的时候再回头看会回味无穷。\n```\n// 函数声明\nfunction foo(){\nvar a = 2;\nconsole.log(a);\n}\nfoo()\n// 函数表达式\n(function foo(){\nvar a = 2;\nconsole.log(a);\n})()\nvar a = 2;\n(function IIFE(global){\nvar a = 3;\nconsole.log(a, global.a)// 3,2\n})(window)\n// 函数表达式\nvar foo = function(){\nconsole.log(1)\n}\n```\n那么怎么搞出一个块作用域呢？块作用域的声明方式有：\n1.  with 仅在with声明中有效\n1.  try/catch catch内的变量仅在catch内使用\n1.  let 劫持所在块的作用域\n1.  const 与let类似，变量不可修改\n块作用域的优势：1. 有利于垃圾回收（块作用域内代码执行后可以直接回收）；2. 解决 var 循环问题。\n# 三、提升\n> 没有赋值只有声明的变量是会报错 undefined，提升也只是提升了个声明而已；再换句话说，赋值可以跑在声明的前面。光说不干假把式~\n第一段代码可以顺利执行，因为对于 a 的声明会提升到最顶部，因此在作用域内能够找到a。但是这第二段代码中，`var a = 2;`会被拆分为两步，第一步是声明 a ，然后就执行了输出语句，还没有进行赋值呢，因此会出现报错。 这个例子恰好说明了“赋值可以跑在声明前面”。\n***\n例二：\n```\nfoo()\nfunction foo(){\nconsole.log(a); //undefined\nvar a;\n}\n```\n这里也是和例一一样，a会提升声明（作用域在foo内），但是只有声明，没有赋值，所以仍然会报错。\n***\n同样是声明提升，***函数的优先级高于变量***。这里的例子我们可以把函数表达式当作是一个变量的声明，相当于给foo2 这个变量赋值了一个函数。那么由于函数的优先级更高，这个foo2无法覆盖之前的foo1，所以输出仍然是1。\n# 四、闭包\n## 1. 闭包是什么\n首先我们得知道闭包是什么，来看看书里是怎么说的：\n> 函数在 定义时的词法作用域以外的地方 被调用，闭包使得函数可以继续访问定义时的词法作用域。\n这句话的形容使闭包看起来像一种_访问作用域的方法_。我们继续看下一句：\n> 无论通过何种手段将内部函数传递到所在的词法作用域以外，它都会持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包。\n**因此，不应该把比较理解成一种现象或者原理，应该作为一种工具方便我们使用来解决 JavaScript 中的一些问题。这是一个重要的理解点。** 用自己的话再来说一下闭包是什么吧：\n一个函数（A）引用着另一个函数的变量（B），即使 B 已经顺利执行结束了也不会被回收，因为 A 还引用着呢，所以 B 的各种变量也要被保存。\n'
      },
    ],
  },
  getters: {
  },
  mutations: {
  },
  actions: {
  },
  modules: {
  }
})
